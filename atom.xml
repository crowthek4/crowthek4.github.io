<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清梦船</title>
  
  <subtitle>~太阳当空照~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://crowzf.com/"/>
  <updated>2018-05-03T06:50:37.261Z</updated>
  <id>https://crowzf.com/</id>
  
  <author>
    <name>王卓夫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>舰娘</title>
    <link href="https://crowzf.com/posts/e012b259/"/>
    <id>https://crowzf.com/posts/e012b259/</id>
    <published>2018-05-03T06:47:01.000Z</published>
    <updated>2018-05-03T06:50:37.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="驱逐舰-DD"><a href="#驱逐舰-DD" class="headerlink" title="驱逐舰 DD"></a>驱逐舰 DD</h2><h3 id="阳炎改二"><a href="#阳炎改二" class="headerlink" title="阳炎改二"></a>阳炎改二</h3><ul><li>装备【12.7cm连装炮C型改二】和【61cm四连装(酸素)鱼类】战力额外增强</li></ul><h2 id="轻巡洋舰"><a href="#轻巡洋舰" class="headerlink" title="轻巡洋舰"></a>轻巡洋舰</h2><h3 id="五十铃改二"><a href="#五十铃改二" class="headerlink" title="五十铃改二"></a>五十铃改二</h3><ul><li>自带开幕反潜，无对潜值要求</li></ul>]]></content>
    
    <summary type="html">
    
      舰娘特别能力
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>开发</title>
    <link href="https://crowzf.com/posts/5b1f4da1/"/>
    <id>https://crowzf.com/posts/5b1f4da1/</id>
    <published>2018-04-29T02:06:17.000Z</published>
    <updated>2018-05-02T03:07:53.187Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">秘书舰</th><th style="text-align:center">公式</th><th style="text-align:center">数量</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">烈风</td><td style="text-align:center">舰上战斗机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">9</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">流星改</td><td style="text-align:center">舰上攻击机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">彗星一二型甲</td><td style="text-align:center">舰上爆击机</td><td style="text-align:center">CV</td><td style="text-align:center">20/30/10/40</td><td style="text-align:center">12</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">零式舰战62型（爆战）</td><td style="text-align:center">舰上爆击机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">彩云</td><td style="text-align:center">舰上侦察机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">二式舰上侦察机</td><td style="text-align:center">舰上侦察机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">零式水上观测机</td><td style="text-align:center">舰上侦察机</td><td style="text-align:center">CV</td><td style="text-align:center">20/11/10/20</td><td style="text-align:center">4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">瑞云</td><td style="text-align:center">水上爆击机</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">46cm三连装炮</td><td style="text-align:center">大口径主炮</td><td style="text-align:center">BB</td><td style="text-align:center">10/251/250/10</td><td style="text-align:center">6(+4)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">三式弹</td><td style="text-align:center">对空强化弹</td><td style="text-align:center"></td><td style="text-align:center">10/90/90/30</td><td style="text-align:center">3</td><td style="text-align:center">对陆基2.5倍</td></tr><tr><td style="text-align:center">九一式彻甲弹</td><td style="text-align:center">对舰强化弹</td><td style="text-align:center"></td><td style="text-align:center">10/251/250/10</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15.5cm三连装炮（副炮）</td><td style="text-align:center">副炮</td><td style="text-align:center"></td><td style="text-align:center">10/251/250/10</td><td style="text-align:center"></td><td style="text-align:center">夜战地图、CLT装备</td></tr><tr><td style="text-align:center">32号对水上电探</td><td style="text-align:center">大型电探</td><td style="text-align:center">CV</td><td style="text-align:center">20/20/250/250</td><td style="text-align:center">2~4(+8)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">14号对空电探</td><td style="text-align:center"></td><td style="text-align:center">CV</td><td style="text-align:center">20/20/250/250</td><td style="text-align:center">0~2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">33号对水上电探</td><td style="text-align:center">小型电探</td><td style="text-align:center">CV</td><td style="text-align:center">20/20/250/250</td><td style="text-align:center">2(4)</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">三式水中探信仪</td><td style="text-align:center">声呐</td><td style="text-align:center">CL/DD</td><td style="text-align:center">10/10/10/20</td><td style="text-align:center">4</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">三式爆雷投射机</td><td style="text-align:center">爆雷</td><td style="text-align:center">CL</td><td style="text-align:center">10/30/10/10</td><td style="text-align:center">2</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      舰C 开发数量及公式
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>+= 操作符实质</title>
    <link href="https://crowzf.com/posts/3ddc283/"/>
    <id>https://crowzf.com/posts/3ddc283/</id>
    <published>2018-04-21T15:10:54.000Z</published>
    <updated>2018-04-21T15:12:29.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作符实质"><a href="#操作符实质" class="headerlink" title="+= 操作符实质"></a>+= 操作符实质</h2><p><code>i += j</code>等同于<code>i = i + j</code>吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> j = <span class="number">8</span>;</span><br><span class="line">i = i + j; <span class="comment">// 不能编译</span></span><br><span class="line">i += j;    <span class="comment">// 可以编译</span></span><br></pre></td></tr></table></figure><p>对<code>符合赋值表达式</code>来说，<code>E1 op= E2</code>等同于<code>E1 = (T)((E1) op (E2))</code>，其中 T 是 E1 的类型。</p>]]></content>
    
    <summary type="html">
    
      += 并非简单的自加后赋值
    
    </summary>
    
    
      <category term="Java坑" scheme="https://crowzf.com/tags/Java%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="https://crowzf.com/posts/7bca204e/"/>
    <id>https://crowzf.com/posts/7bca204e/</id>
    <published>2018-04-21T15:06:36.000Z</published>
    <updated>2018-04-21T15:54:22.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-IO-操作"><a href="#Java-IO-操作" class="headerlink" title="Java IO 操作"></a>Java IO 操作</h1><p>[TOC]</p><h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>在程序中所有的数据都是以流的方式进行传输或保存的，程序中需要数据的时候就用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。</p><p><img src="https://img-blog.csdn.net/20160715111022976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>程序中的输入输出都是以流的形式保存的，流中保存的实际上全部是字节文件。</p><p>一个流可以理解为输入的序列。</p><h2 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h2><p>在 java.io 包中操作文件内容的主要有两大类：字节流和字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用 OutputStream 完成，输入使用 InputStream，在字符流中输出主要是使用 Writer 类完成，输入主要是使用 Reader 类完成。</p><p>内容操作一共四个类：OutputStream、InputStream、Writer、Reader</p><p><img src="https://i.imgur.com/pfcMtbJ.png" alt="Imgur"></p><p>操作流程：</p><p>在 Java 中 IO 操作也是有相应步骤的，以文件操作为例，主要操作流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: ①使用 File 类打开一个文件</span><br><span class="line">op2=&gt;operation: ②通过字节流或字符流的子类，指定输出的位置</span><br><span class="line">op3=&gt;operation: ③进行读/写操作</span><br><span class="line">op4=&gt;operation: ④关闭输入/输出流</span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;e</span><br></pre></td></tr></table></figure><ol><li>使用 File 类打开一个文件</li><li>通过字节流或字符流的子类，指定输出的位置</li><li>进行读/写操作</li><li>关闭输入/输出</li></ol><p>使用 File 类操作的时候一定要有路径的问题，注意分隔符（File.separator）。</p><p>实际上四个操作类都是抽象类</p><p>IO 操作属于资源操作，对于资源操作，操作的最后必须关闭，否则就有可能出现未知的错误。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流主要是操作 byte 类型的数据，以 byte 数组为准，主要操作类是 OutputStream、InputStream</p><p>字节输出流：OutputStream</p><p>字节输入流：InputStream</p><p>Byte 是字节，肯定使用字节流操作。所有的数据基本上都可以直接使用 byte 数组表示出来。</p><h3 id="字节输出流-OutputStream"><a href="#字节输出流-OutputStream" class="headerlink" title="字节输出流 OutputStream"></a>字节输出流 OutputStream</h3><p>OutputStream 是整个 io 包中字节输出流的最大父类，此类的定义如下：</p><p><code>public abstract class OutputStream extends Object implements Closeable, Flushable</code></p><p>从以上的定义可以发现，此类是一个<strong>抽象类</strong>，如果要想使用此类的话，则首先必须<strong>通过子类实例化对象</strong>，那么如果现在要操作的是一个文件，则可以使用：FileOutputStream 类。通过向上转型之后，可以为 OutputStream 实例化。</p><p>Closeable 表示可以关闭的操作，因为程序运行到最后肯定要关闭。</p><p>Flushable 接口表示刷新，清空内存中的数据。</p><p>OutputStream 类的常用方法：</p><p>1、<code>public void close() throws IOException</code>  关闭输出流</p><p>2、<code>public void flush() throws IOException</code>  刷新缓冲区</p><p>3、<code>public void write(byte[] b) throws IOException</code> 将一个 byte 数组写入数据流</p><p>4、<code>public void write(byte[] b,int off,int len) throws IOException</code> 将一个指定范围的byte数组写入数据流</p><p>5、<code>public abstract void write(int b) throws IOException</code>  将一个字节数据写入数据流</p><p>要想使用以上方法，必须使用子类实例化，此时使用 FileOutputStream 子类，此类的构造方法如下：</p><p><code>public FileOutputStream(File file) throws IOException</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutpusStreamDemo01</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抛出异常，不处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 第1步，使用 File 类找到一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第2步，通过子类实例化父类对象</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f); <span class="comment">// 通过对象多态性，进行实例化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第3步，进行写操作</span></span><br><span class="line">        String str = <span class="string">"Hello World!"</span> <span class="comment">// 准备好一个字符串</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = str.getBytes(); <span class="comment">// 只能输出 byte 数组，所以将字符串变为 byte 数组</span></span><br><span class="line">        out.write(b);              <span class="comment">// 将内容输出，保存成文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第4步，关闭输出流</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在操作的时候，如果文件本身不存在，则会为用户自动创建新文件。</p><p>在操作输出流的时候，也可以使用<code>write(int i)</code>的方法写出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第1步，使用 File 类找到一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第2步，通过子类实例化父类对象</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第3步，进行写操作</span></span><br><span class="line">        String str = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            out.write(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第4步，关闭输出流</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的操作中在写入数据之前，文件之前的内容已经不存在了，因为在 IO 操作中默认的情况是将其进行覆盖的，那么现在要想执行追加的功能，则必须设置追加的操作，找到 FileOutputStream 类：</p><p><strong>追加新内容</strong></p><p>之前的所有操作中，如果重新执行程序，则肯定会覆盖文件中的已有内容，那么此时就可以通过<code>FileOutputStream</code>向文件中追加内容，<code>FileOutputStream</code>的另外一个构造方法：</p><p><code>public FileOutputStream(File file,boolean append) throws FileNotFoundException</code></p><p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 第1步，使用 File 类找到一个文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第2步，通过子类实例化父类对象，第二个参数设置为 true 以追加内容而非覆盖改写</span></span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第3步，进行写操作</span></span><br><span class="line">        String str = <span class="string">"Hello World!"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b = str.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            our.write(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第4步，关闭输出流</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717154344539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><br>程序本身是可以追加内容的，但是没有换行，是直接在末尾追加的。</p><p>如果在文件操作中想换行的话，使用”\r\n”(Windows)或 “\n”(Mac) 完成。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">        String str = <span class="string">"\r\nHello world!"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> str.getBytes();</span><br><span class="line">        out.write(b);</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节输入流-InputStream"><a href="#字节输入流-InputStream" class="headerlink" title="字节输入流 InputStream"></a>字节输入流 InputStream</h3><p> 既然程序可以向文件中写入内容，则就可以通过InputStream 从文件中读取出来，首先看InputStream 类的定义：</p><p><code>public abstract class InputStream extends Object implements Closeable</code></p><p>与 OutputStream 类一样，InputStream 本身也是一个抽象类，必须依靠其子类，如果现在是从文件中读取，子类肯定是 FileInputStream。观察FileInputStream 类的构造方法：</p><p><code>public FileInputStream(File file) throws FileNotFoundException</code></p><p>InputStream 类的常用方法如下：</p><ol><li><p><code>public int available() throws IOException</code>  可以取得输入文件的大小。</p></li><li><p><code>public void close() throws IOException</code>  关闭输入流</p></li><li><p><code>public abstract int read() throws IOException</code> 读取内容，将其作为 int 类型返回。</p></li><li><p><code>public int read(byte[] b) throws IOException</code> 将内容读取到 byte 数组之中，并将读到的内容作为 int 类型返回。</p><p><code>read()</code>以 int 作为返回值类型是因为该方法在底层是 C++ 实现的，返回一个 unsigned byte，范围是 [0, 255]。Java 中没有对应的类型表示这个范围，byte 范围是[-128, 127]。所以用 int 接收。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        input.read(b);</span><br><span class="line">        input.close();</span><br><span class="line">        <span class="comment">// 把 byte 数组变为字符串输出</span></span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717171102968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>此时，内容已经确实被读出来了，但是存在问题，声明 b数组时把容量定为1024，多出来的显示为方块。</p><p>初步修改代码后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);</span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = input.read(b);</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">        System.out.println(<span class="string">"读入数据的长度： "</span> + b);</span><br><span class="line">        <span class="comment">// 把 byte 数组变为字符串输出</span></span><br><span class="line">        System.out.println(<span class="string">"内容为： "</span> + <span class="keyword">new</span> String(b, <span class="number">0</span>, len));  <span class="comment">//指定转成字符串时提取数组中那些元素。第二个参数是偏移量 offset，表示要转换的第一个元素，第3个参数表示要转换的最后一个元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717172437617?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>以上代码还是存在问题。文件没有那么大，但是开辟了很大的数组空间，肯定浪费很多内存，应该根据文件的大小来开辟数组空间。如果想知道文件的大小，直接使用 File 类即可。</p><p><code>public long length()</code></p><p><strong>开辟指定大小的空间</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File ;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream ;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream ;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        InputStream input = <span class="keyword">null</span> ;  <span class="comment">// 准备好一个输入的对象  </span></span><br><span class="line"></span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(f)  ;   <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作  </span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()] ;      <span class="comment">// 数组大小由文件决定  </span></span><br><span class="line">        <span class="keyword">int</span> len = input.read(b) ;       <span class="comment">// 读取内容  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        input.close() ;                     <span class="comment">// 关闭输出流</span></span><br><span class="line">        System.out.println(<span class="string">"读入数据的长度："</span> + len) ;  </span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(b)) ;    <span class="comment">// 把byte数组变为字符串输出  </span></span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717173405427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>以上是直接使用 byte 数组的方式完成的，还可以使用一下方式进行读取。</p><p><code>public abstract int read() throws IOException</code>逐个字节进行内容读取</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File ;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream ;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream ;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamDemo04</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        InputStream input = <span class="keyword">null</span> ;  <span class="comment">// 准备好一个输入的对象  </span></span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(f)  ;   <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作  </span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()] ;      <span class="comment">// 数组大小由文件决定  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)&#123;  </span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)input.read() ;     <span class="comment">// 读取内容 </span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        input.close() ;                     <span class="comment">// 关闭输出流</span></span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(b)) ;    <span class="comment">// 把byte数组变为字符串输出  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717174018326?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>以上操作只适合于知道输入流大小的时候，如果现在不知道大小呢？</p><p>需要根据读取的标志-1进行判断是否结束，因为<code>read()</code>方法返回读取到的元素个数，当没有读取到任何元素时，将返回-1。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamDemo05</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        InputStream input = <span class="keyword">null</span> ;  <span class="comment">// 准备好一个输入的对象  </span></span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(f)  ;   <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作  </span></span><br><span class="line">        <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>] ;     <span class="comment">// 数组大小由文件决定  </span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;   </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span> ;          <span class="comment">// 接收每一个读取进来的数据  </span></span><br><span class="line">        <span class="keyword">while</span>((temp = input.read()) != -<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="comment">// 表示还有内容，文件没有读完  </span></span><br><span class="line">            b[len] = (<span class="keyword">byte</span>)temp ;  </span><br><span class="line">            len++ ;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        input.close() ;                     <span class="comment">// 关闭输出流</span></span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(b, <span class="number">0</span>, len)) ;  <span class="comment">// 把 byte 数组变为字符串输出  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在程序中一个字符等于2个字节，那么JAVA提供了Reader、Writer两个专门操作字符流的类。</p><h3 id="字符输出流：Writer"><a href="#字符输出流：Writer" class="headerlink" title="字符输出流：Writer"></a>字符输出流：Writer</h3><p>Writer 本身是一个字符流的输出类，此类的定义如下：</p><p><code>public abstract class Writer extends Object implements Appendable，Closeable,，Flushable</code></p><p>此类也是一个抽象类，如果要想使用此类，则肯定要使用其子类。此时如果是向文件中写入内容，所以应该使用 FileWriter 的子类。</p><p>FileWriter 类的构造方法定义如下：</p><p><code>public FileWriter(File file) throws IOException</code></p><p>Writer类的常用方法</p><ol><li><code>public abstract void close() throws IOException</code>  关闭输出流</li><li><code>public void write(String str) throws IOException</code> 将字符串输出</li><li><code>public void write(char[] cbuf) throws IOException</code> 将字符数组输出</li><li><code>public abstract void flush() throws IOException</code> 强制性清空缓存</li></ol><p>字符流的操作比字节流操作好在一点，就是可以直接输出字符串。不在用再像之前那样进行字节转换操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File ;  </span><br><span class="line"><span class="keyword">import</span> java.io.Writer ;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter ;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo01</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Writer out = <span class="keyword">null</span> ; <span class="comment">// 准备好一个输出的对象  </span></span><br><span class="line">        out = <span class="keyword">new</span> FileWriter(f)  ;  <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作  </span></span><br><span class="line">        String str = <span class="string">"Hello World!!!"</span> ;     <span class="comment">// 准备一个字符串  </span></span><br><span class="line">        out.write(str) ;                    <span class="comment">// 将内容输出，保存文件  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        out.close() ;                       <span class="comment">// 关闭输出流  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字符流默认情况下依然是覆盖已有的文件，如果想追加的话，则直接在 FileWriter 上增加一个可追加标记即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File ;  </span><br><span class="line"><span class="keyword">import</span> java.io.Writer ;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter ;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo02</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Writer out = <span class="keyword">null</span> ; <span class="comment">// 准备好一个输出的对象  </span></span><br><span class="line">        out = <span class="keyword">new</span> FileWriter(f,<span class="keyword">true</span>)  ; <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作  </span></span><br><span class="line">        String str = <span class="string">"\r\n我\r\nHello World!!!"</span> ;       <span class="comment">// 准备一个字符串  </span></span><br><span class="line">        out.write(str) ;                        <span class="comment">// 将内容输出，保存文件  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        out.close() ;                       <span class="comment">// 关闭输出流  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符输入流：Reader"><a href="#字符输入流：Reader" class="headerlink" title="字符输入流：Reader"></a>字符输入流：Reader</h3><p>Reader 是使用字符的方式从文件之中取出数据，Reader类的定义如下：</p><p><code>public abstract class Reader extends Object implements Readable，Closeable</code></p><p>Reader 本身也是抽象类，如果现在要从文件中读取内容，则可以直接使用 FileReader 子类。</p><p>FileReader 的构造方法定义如下：</p><p><code>public FileReader(File file) throws FileNotFOundException</code></p><p>Reader类的常用方法：</p><ol><li><code>public abstract void close() throws IOException</code> 关闭输出流</li><li><code>public int read() throws IOException</code> 读取单个字符</li><li><code>public int read(char[] cbuf) throws IOException</code> 将字符读取到字符数组之中，返回读入的长度。</li></ol><p>以字符数组的形式读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.Reader;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo01</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Reader input = <span class="keyword">null</span> ;   <span class="comment">// 准备好一个输入的对象  </span></span><br><span class="line">        input = <span class="keyword">new</span> FileReader(f)  ;    <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作  </span></span><br><span class="line">        <span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>] ;     <span class="comment">// 所有的内容都读到此数组之中  </span></span><br><span class="line">        <span class="keyword">int</span> len = input.read(c) ;       <span class="comment">// 读取内容  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        input.close() ;                     <span class="comment">// 关闭输出流  </span></span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(c, <span class="number">0</span>, len)) ;  <span class="comment">// 把字符数组变为字符串输出  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也可以通过循环的方式，通过判断文件是否读取到底的形式，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.Reader;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo02</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Reader input = <span class="keyword">null</span>;   <span class="comment">// 准备好一个输入的对象  </span></span><br><span class="line">        input = <span class="keyword">new</span> FileReader(f);   <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行读操作  </span></span><br><span class="line">        <span class="keyword">char</span> c[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];     <span class="comment">// 所有的内容都读到此数组之中  </span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;  <span class="comment">// 接收每一个内容  </span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;       <span class="comment">// 读取内容  </span></span><br><span class="line">        <span class="keyword">while</span>((temp=input.read()) != -<span class="number">1</span>) &#123;  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不是-1就表示还有内容，可以继续读取  </span></span><br><span class="line">            c[len] = (<span class="keyword">char</span>)temp;  </span><br><span class="line">            len++;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        input.close();                     <span class="comment">// 关闭输出流  </span></span><br><span class="line">        System.out.println(<span class="string">"内容为："</span> + <span class="keyword">new</span> String(c, <span class="number">0</span>, len));  <span class="comment">// 把字符数组变为字符串输出  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>字节流在操作的时候本身是不会用到缓冲区(内存)的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的。</p><p><img src="https://img-blog.csdn.net/20160717190421674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>通过一个代码来验证字符流使用到了缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamDemo05</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">//异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;   <span class="comment">// 准备好一个输出的对象  </span></span><br><span class="line">        out = <span class="keyword">new</span> FileOutputStream(f);    <span class="comment">// 实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作  </span></span><br><span class="line">        String str = <span class="string">"Hello World!!!"</span>;     <span class="comment">// 准备一个字符串  </span></span><br><span class="line">        <span class="keyword">byte</span> b[] = str.getBytes() ;         <span class="comment">// 只能输出byte数组，所以将字符串变为byte数组  </span></span><br><span class="line"></span><br><span class="line">        out.write(b);    <span class="comment">// 写入数据  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        <span class="comment">// out.close();                       // 关闭输出流  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20160717190739066?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>在使用字节流操作中，即使没有关闭，最终也是可以输出的</p><p>使用字符流，如果不关闭，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.Writer;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo03</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>);  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Writer out = <span class="keyword">null</span>; <span class="comment">// 准备好一个输出的对象  </span></span><br><span class="line">        out = <span class="keyword">new</span> FileWriter(f);  <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作  </span></span><br><span class="line">        String str = <span class="string">"Hello World!!!"</span> ;     <span class="comment">// 准备一个字符串  </span></span><br><span class="line">        out.write(str);                       <span class="comment">// 将内容输出，保存文件  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        <span class="comment">// out.close();                        // 此时，没有关闭  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://img-blog.csdn.net/20160717191025270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>以上的操作，没有输出任何的内容，以前的内容也会被清空，也就是说，所有的内容现在都是保存在缓冲区中，如果执行关闭操作的时候会强制刷新缓冲区，所以可以把内容输出。</p><p>如果现在假设，没有关闭的话，也可以手工强制性调用刷新方法</p><p><code>public abstract void flush() throws IOException</code></p><p>程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File ;  </span><br><span class="line"><span class="keyword">import</span> java.io.Writer ;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter ;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterDemo04</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;    <span class="comment">// 异常抛出，不处理  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第1步、使用File类找到一个文件  </span></span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"test.txt"</span>) ;  <span class="comment">// 声明File对象  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第2步、通过子类实例化父类对象  </span></span><br><span class="line">        Writer out = <span class="keyword">null</span> ; <span class="comment">// 准备好一个输出的对象  </span></span><br><span class="line">        out = <span class="keyword">new</span> FileWriter(f)  ;  <span class="comment">// 通过对象多态性，进行实例化  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第3步、进行写操作  </span></span><br><span class="line">        String str = <span class="string">"Hello World!!!"</span> ;     <span class="comment">// 准备一个字符串  </span></span><br><span class="line">        out.write(str) ;                        <span class="comment">// 将内容输出，保存文件  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第4步、关闭输出流  </span></span><br><span class="line">        out.flush() ;   <span class="comment">// 强制性清空缓冲区中的内容  </span></span><br><span class="line">        <span class="comment">// out.close() ;                        // 此时，没有关闭  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>开发中是使用字节流好还是使用字符流好？</strong></p><p> 在所有的硬盘上保存文件或是进行传输的时候都是以字节的方式进行的，包括图片也是按照字节完成，而字符是只有在内存中才会形成的，所以使用字节操作是最多的。</p><h2 id="操作范例"><a href="#操作范例" class="headerlink" title="操作范例"></a>操作范例</h2><p>文件拷贝：在 DOS 命令中存在一个文件的拷贝命令(copy)，例如：现在要将 D 盘中的 test.txt 文件拷贝到 D 盘中的 demo.txt 文件中，则只要在命令行输入 copy 即可完成</p><p>copy命令的语法格式如下：</p><p><code>copy 源文件 目标文件</code></p><p>如果要采用以上的格式，则肯定要使用初始化参数的形式，输入两个路径，所以此时就必须对输入参数的个数进行验证，判断其是否为2</p><p>是使用字符流还是使用字节流呢？答案是肯定选择字节流，因为万一拷贝的是一个图片，字符流是读不出东西的。</p><p>  实现一：将源文件中的内容全部读取进来，之后一次性的写入到目标文件</p><p>  实现二：边读取边写入的方式</p><p>很明显是使用第二种方式</p><p>程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否是两个参数</span></span><br><span class="line">            <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"输入的参数不正确。"</span>);</span><br><span class="line">                System.out.println(<span class="string">"例：java Copy 源文件路径 目标文件路径"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);    <span class="comment">// 系统退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            File f1 = <span class="keyword">new</span> File(args[<span class="number">0</span>]);   <span class="comment">// 源文件的 File 对象</span></span><br><span class="line">            File f2 = <span class="keyword">new</span> File(args[<span class="number">1</span>]);   <span class="comment">// 目标文件的 File 对象</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!f1.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"源文件不存在！"</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            InputStream input = <span class="keyword">null</span>;      <span class="comment">// 准备好输入流对象，读取源文件</span></span><br><span class="line">            OutputStream out = <span class="keyword">null</span>;       <span class="comment">// 准备好输出流对象，写入目标文件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input = <span class="keyword">new</span> FileInputStream(f1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span> &amp;&amp; out != <span class="keyword">null</span>)&#123;   <span class="comment">// 判断输入或输出是否准备好</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((temp=input.read()) != -<span class="number">1</span>) &#123; <span class="comment">// 开始拷贝</span></span><br><span class="line">                        out.write(temp);   <span class="comment">// 边读边写</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"拷贝完成！"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">"拷贝失败！"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input.close();     <span class="comment">// 关闭</span></span><br><span class="line">                    out.close();       <span class="comment">// 关闭</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、掌握流的概念</p><p>2、掌握字节流和字符流操作文件的基本步骤（以后所有操作都可以使用以上代码完成）</p><p>3、字节流和字符流的区别</p><p>​    字节流：没有使用到缓冲区</p><p>​    字符流：使用到了缓冲区</p><p>4、边度边写的方式是开发中非常有用的方式</p>]]></content>
    
    <summary type="html">
    
      字节流、字符流
    
    </summary>
    
    
      <category term="Java, IO" scheme="https://crowzf.com/tags/Java-IO/"/>
    
  </entry>
  
  <entry>
    <title>运行 java 代码时提示找不到或无法加载主类</title>
    <link href="https://crowzf.com/posts/2ef061ea/"/>
    <id>https://crowzf.com/posts/2ef061ea/</id>
    <published>2018-04-18T15:01:39.000Z</published>
    <updated>2018-04-19T02:18:57.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><p>如果源代码在某个包中，要退回到<strong>包所在路径</strong>，而不要 cd 进入包文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;Mac&quot;&gt;&lt;a href=&quot;#Mac&quot; class=&quot;headerlink&quot; title=&quot;Mac&quot;&gt;&lt;/a&gt;Mac&lt;/h2&gt;&lt;p&gt;如果源代码在某个包中，要退回到&lt;strong&gt;包所在路径&lt;/strong&gt;，而不要 cd
        
      
    
    </summary>
    
    
      <category term="Java 坑" scheme="https://crowzf.com/tags/Java-%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>lambda 表达式</title>
    <link href="https://crowzf.com/posts/889824bc/"/>
    <id>https://crowzf.com/posts/889824bc/</id>
    <published>2018-04-18T14:12:43.000Z</published>
    <updated>2018-04-21T15:06:13.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Lmbda 表达式是一个可传递的代码块。一个没有名字的方法，类似闭包。Lmabda 也是一种对象，他依存于函数式接口。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>参数，箭头（-&gt;），表达式：</p><p>(parameters) -&gt; expression</p><p>(parameters) -&gt; { statements; }</p><ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：<code>(int a)</code>与<code>(a)</code>效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：<code>(a, b)</code> 或 <code>(int a, int b)</code> 或 <code>(String a, int b, float c)</code></li><li>空圆括号代表参数集为空。例如：<code>() -&gt; 42</code></li><li>当只有一个参数，且其类型可推导时，则圆括号（）可省略。例如：<code>a -&gt; return a*a</code></li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，则花括号 {} 可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ul><p>如果一个 lambda 表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下表达式不合法</span></span><br><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口（functional-interface）"><a href="#函数式接口（functional-interface）" class="headerlink" title="函数式接口（functional interface）"></a>函数式接口（functional interface）</h2><p>只包含一个抽象方法的接口。</p><p>例如<code>java.lang.Runnable</code>接口只有一个方法<code>run()</code>，它就是一个函数式接口。</p><p>以往需要匿名内部类来实例化函数式接口的对象，现在则可使用 lambda 表达式。</p><p>需要实现这种接口的类的对象时，就可以提供一个 lambda 表达式。</p><p>每个 lambda 表达式都可以隐式地赋值给函数式接口。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"Hello, world"</span>);</span><br></pre></td></tr></table></figure><p>即使未指定赋值给哪个函数式接口，编译器也会将其转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello, world"</span>)).start();</span><br></pre></td></tr></table></figure><p>在上面的代码中，编译器会自动推断：根据<code>Theard</code>类的构造函数签名 <code>public Thread(Runnable r) { }</code>，将该 Lambda 表达式赋给 Runnable 接口。</p><h4 id="定义一个函数式接口"><a href="#定义一个函数式接口" class="headerlink" title="定义一个函数式接口"></a>定义一个函数式接口</h4><p>使用 @FunctionalInterface:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-表达式用例"><a href="#Lambda-表达式用例" class="headerlink" title="Lambda 表达式用例"></a>Lambda 表达式用例</h2><h4 id="初始化线程"><a href="#初始化线程" class="headerlink" title="初始化线程"></a>初始化线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程实例，线程名</span></span><br><span class="line">    <span class="keyword">private</span> Thread myThread;</span><br><span class="line">    <span class="keyword">private</span> String threadName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    MyRunnable(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = name;</span><br><span class="line">        System.out.println(<span class="string">"Creating "</span> + threadName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MyRunnable 的实例</span></span><br><span class="line">    Runnable threadOb = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实例化一个线程对象</span></span><br><span class="line">    <span class="comment">// 线程处于 New 状态</span></span><br><span class="line">    Thread myThread = <span class="keyword">new</span> Thread(threadOb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 Runnbale 接口中的 run() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Running "</span> + threadNmae);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                System.out.printlnI(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">"interrupted."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">"exiting."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Starting "</span> + threadName );</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, threadName);</span><br><span class="line">            t.start()；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Runnable 状态</span></span><br><span class="line">    myThread.start();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>当有现成的方法可以完成想要传递到其他代码的某个动作时，可以直接将方法传递过去，称为方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event -&gt; System.out.println(event));</span><br><span class="line"><span class="comment">// 方法引用写法</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, System.out::println);</span><br><span class="line"><span class="comment">// System.out::println 等价于 x -&gt; System.out.println(event);</span></span><br></pre></td></tr></table></figure><p>使用 <code>::</code> 操作符分割方法名与对象或类名，主要有 3 种情况：</p><ul><li>object :: instanceMethod</li><li>Class :: staticMethod</li><li>Class :: instanceMethod</li></ul><p>前两种情况中，方法引用等价于提供方法参数的 lambda 表达式。即 <code>Math :: pow</code> 等价于 <code>(x, y) -&gt; Math.pow(x, y)</code></p><p>对于第 3 种情况，第 1 个参数会成为方法的目标。例如：<code>String :: compareToIgnoreCase</code> 等价于 <code>x -&gt; x.compareToIgnoreCase(y)</code></p><p>可以在方法引用中使用 this/super 参数。例如：<code>this :: equals</code> 等价于 <code>x -&gt; this.equals(x)</code></p><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p><code>Person::new</code></p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>lambda 表达式可以捕获其外部的方法或类中的变量。</p>]]></content>
    
    <summary type="html">
    
      Lambda 表达式的概念、语法与应用
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 搭建博客</title>
    <link href="https://crowzf.com/posts/b6159bfb/"/>
    <id>https://crowzf.com/posts/b6159bfb/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-17T05:57:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo + Github + Yelee 搭建博客及深度优化</p><a id="more"></a> <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p><code>站点配置文件</code>:  位于站点文件夹根目录内：</p><p><code>~/blog/_config.yml</code></p></li><li><p><code>主题配置文件</code>:</p><p><code>~/blog/themes/next/config.yml</code></p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装<code>Node.js</code></h3><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Windows</a> </li><li><a href="https://nodejs.org/en" target="_blank" rel="noopener">Mac</a></li></ul><p>安装<code>Node.js</code>会自动安装<code>npm</code></p><p>随<code>Node.js</code>安装的<code>npm</code>可能不是最新版，执行<code>npm i npm</code>以更新。</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装<code>Git</code></h3><ul><li><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Windows</a></li><li>Mac<ol><li>安装<code>Homebrew</code>:<code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li><li>安装<code>Git</code>:<code>brew install git</code></li></ol></li></ul><h3 id="新建Git仓库"><a href="#新建Git仓库" class="headerlink" title="新建Git仓库"></a>新建<code>Git</code>仓库</h3><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装<code>Hexo</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment">#将hexo安装至默认文件夹，使用全局设置下载</span></span><br><span class="line">hexo init blog          <span class="comment">#初始化博客文件夹</span></span><br><span class="line"><span class="built_in">cd</span> blog                 <span class="comment">#进入博客文件夹</span></span><br><span class="line">npm install             <span class="comment">#安装指定模块，json指定</span></span><br></pre></td></tr></table></figure><h3 id="包更新"><a href="#包更新" class="headerlink" title="包更新"></a>包更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新全局安装的包</span></span><br><span class="line">$ npm update -g </span><br><span class="line"></span><br><span class="line"><span class="comment">#更新当前文件夹下安装的依赖包</span></span><br><span class="line">$ npm update         </span><br><span class="line"></span><br><span class="line"><span class="comment">#更新npm</span></span><br><span class="line">$ npm install npm -g </span><br><span class="line"></span><br><span class="line"><span class="comment">#更新Node.js</span></span><br><span class="line">$ npm install n -g   </span><br><span class="line">$ n latest</span><br></pre></td></tr></table></figure><h2 id="Hexo-常用命令"><a href="#Hexo-常用命令" class="headerlink" title="Hexo 常用命令"></a>Hexo 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建文章</span></span><br><span class="line">$ hexo n(ew) file</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建页面（需要配置index.md中的type:""，并主题文件夹中的_config中添加相应的 menu 字段，以及FontAwsome中的图标）</span></span><br><span class="line">$ hexo n page <span class="string">"page"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#由md文件生成html静态文件</span></span><br><span class="line">$ hexo g(enerate)    </span><br><span class="line"></span><br><span class="line"><span class="comment">#在本地启动http服务以提供本地预览功能</span></span><br><span class="line">$ hexo s(erver)    </span><br><span class="line"></span><br><span class="line"><span class="comment">#部署到git(见深度优化)</span></span><br><span class="line">$ hexo d(eploy)      </span><br><span class="line"></span><br><span class="line"><span class="comment">#渲染指定的md，输出为html格式</span></span><br><span class="line">$ hexo render &lt;file&gt; -o &lt;ouput&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">#清除db.json与public里面的内容</span></span><br><span class="line">$ hexo clean          </span><br><span class="line"></span><br><span class="line"><span class="comment">#列出指定信息，比如tag，post等等</span></span><br><span class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="配置站点"><a href="#配置站点" class="headerlink" title="配置站点"></a>配置站点</h2><h4 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><h4 id="安装-Yelee"><a href="#安装-Yelee" class="headerlink" title="安装 Yelee"></a>安装 <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure><p>修改 <code>站点配置文件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: Yelee</span><br></pre></td></tr></table></figure><h4 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> themes/yelee</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="个人头像"><a href="#个人头像" class="headerlink" title="个人头像"></a>个人头像</h4><p>修改<code>yelee/source/img/avatar/png</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /img/avatar.png</span><br></pre></td></tr></table></figure><h4 id="评论设置"><a href="#评论设置" class="headerlink" title="评论设置"></a>评论设置</h4><p>去掉 Disqus 前的注释 # 号。</p><p>申请 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a></p><p>填入 <code>shortname</code> 在<a href="https://crowthek4.disqus.com/admin/settings/general/" target="_blank" rel="noopener">这里</a>查询自己的 shortname</p><h4 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>去掉<code>search</code>前的注释 # 号</p><p>修改<code>站点配置文件</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 站内搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h4 id="站点图片"><a href="#站点图片" class="headerlink" title="站点图片"></a>站点图片</h4><p><code>yelee/source/favicon.png</code></p><h4 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>修改<code>站点配置文件</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># RSS</span><br><span class="line">feed:</span><br><span class="line">  type: atom       #Feed 类型(atom/rss2)</span><br><span class="line">  path: atom.xml   #Feed 路径(默认：atom.xml/rss2.xml)</span><br><span class="line">  limit: 20         #Feed中显示的最大文章数量('0'显示全部)</span><br><span class="line">  hub:             #PubSubHubhub URL(未使用留空)</span><br><span class="line">  content: </span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: ' '</span><br></pre></td></tr></table></figure></p><h4 id="自定-404-页面"><a href="#自定-404-页面" class="headerlink" title="自定 404 页面"></a>自定 404 页面</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page 404</span><br></pre></td></tr></table></figure><p><code>/source/404/index.md</code>文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 404 Not Found: 该页无法显示</span><br><span class="line">toc: false</span><br><span class="line">comments: false</span><br><span class="line">permalink: /404</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="代码高亮风格"><a href="#代码高亮风格" class="headerlink" title="代码高亮风格"></a>代码高亮风格</h4><p>修改<code>主题配置文件</code></p><h4 id="快引用风格"><a href="#快引用风格" class="headerlink" title="快引用风格"></a>快引用风格</h4><p>修改<code>主题配置文件</code></p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">date: 2018-04-14 22:55   #日期</span><br><span class="line">status: public           #公开</span><br><span class="line">title: hexo 安装          #文章名</span><br><span class="line">tags: 博客搭建             #标签</span><br><span class="line">categlory: 工具           #文章分类</span><br><span class="line">top: true                #置顶（需要 ）</span><br><span class="line">password: abc            #查看所需密码（需要 ）</span><br><span class="line">abbrlink: xxxxx          #永久唯一链接（需要abbrlink插件）</span><br><span class="line">discription: "摘要"      #摘要</span><br><span class="line">toc: false               #关闭目录</span><br></pre></td></tr></table></figure><h2 id="深度优化"><a href="#深度优化" class="headerlink" title="深度优化"></a>深度优化</h2><h3 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h3><p>更改文章题目或者变更文章发布时间时，在默认设置下文章链接会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装此插件后，不要在 <code>hexo s</code> 模式下更改文章文件名，否则文章将成空白。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>在<code>站点配置文件</code>中查找代码<code>permalink</code>:，将其更改为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># “posts/” 可自行更换</span><br><span class="line">permalink: pssts/:abbrlink/</span><br></pre></td></tr></table></figure><p>在<code>站点配置文件</code>中添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># abbrlink config</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32 </span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure><p>可参照样例以选择：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/65535.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/1690090958.html</span><br></pre></td></tr></table></figure><h3 id="Git部署工具"><a href="#Git部署工具" class="headerlink" title="Git部署工具"></a><code>Git</code>部署工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改<code>站点配置文件</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- type:</span><br><span class="line">+ type: git</span><br><span class="line">+ repo: https://github.com/username/username.github.io.git</span><br><span class="line">+ branch: master</span><br></pre></td></tr></table></figure><h3 id="角标注解"><a href="#角标注解" class="headerlink" title="角标注解"></a>角标注解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-footnotes --save</span><br></pre></td></tr></table></figure><p>如未自动开启，可手动修改<code>站点配置文件</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - hexo-footnotes</span><br></pre></td></tr></table></figure><h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p><img src="https://i.imgur.com/pvxFwq7.gif" alt="效果图"></p><p>在<code>themes/next/source/css/_common/components/post/post.styl</code>中添加如下CSS样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">// 选择.post-body不影响标题</span><br><span class="line">// 选择 p 不影响首页“阅读全文的显示样式”</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">    <span class="attribute">border-bootom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">        <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文章底部标签前的-‘-’"><a href="#修改文章底部标签前的-‘-’" class="headerlink" title="修改文章底部标签前的 ‘#’"></a>修改文章底部标签前的 ‘#’</h3><p>修改<code>/themes/next/layout/_macro/post.siwg</code>，搜索<code>ref=&quot;rag&quot;&gt;#</code>，将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h3 id="修改代码块样式"><a href="#修改代码块样式" class="headerlink" title="修改代码块样式"></a>修改代码块样式</h3><p><img src="https://imgur.com/Q2K0S0i.png" alt="效果图"></p><p>修改<code>/themes/next/source/css/_custom.styl</code>加入代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ``自定义样式</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7600</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fb7f8</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ```代码块自定义样式</span><br><span class="line"><span class="selector-class">.heighlight</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heighlight</span>, <span class="selector-tag">code</span>, <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> dolid <span class="number">#d6d6d6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p><a href="cn.aliyun.com">阿里云</a></p><h3 id="解析DNS"><a href="#解析DNS" class="headerlink" title="解析DNS"></a>解析DNS</h3><p>记录类型：CNAME</p><p>主机记录：@/www</p><p>解析线路(isp)：默认</p><p>记录值：crowthek4.github.io</p><h3 id="在Hexo中添加CNAME文件"><a href="#在Hexo中添加CNAME文件" class="headerlink" title="在Hexo中添加CNAME文件"></a>在Hexo中添加CNAME文件</h3><p>内容为域名: crowzf.com</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo + Github + Yelee 搭建博客及深度优化&lt;/p&gt;
    
    </summary>
    
    
      <category term="建站" scheme="https://crowzf.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>重载与重写</title>
    <link href="https://crowzf.com/posts/d1132592/"/>
    <id>https://crowzf.com/posts/d1132592/</id>
    <published>2018-04-12T03:17:27.000Z</published>
    <updated>2018-04-17T06:01:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>重载 VS 重写</p><a id="more"></a><h2 id="重载overload"><a href="#重载overload" class="headerlink" title="重载overload"></a>重载overload</h2><ul><li>与继承无关、与多态无关</li><li>一系列同名、同时存在的方法。</li><li>参数列表必须不同，依据参数列表决定调用哪个方法。</li><li>重载不必遵守父类的多态合同，更加灵活。最常用的是构造器的重载，即一个类有多个构造器（自定构造器，默认构造器等）</li><li>返回值类型可以不同</li><li>访问修饰符可以不同</li><li>可以声明新的或更广泛的检查异常</li><li>能够在同一个类中重载方法，也可以在子类中重载方法</li></ul><hr><h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 Override"></a>重写 Override</h2><p>子类对父类中某个允许访问的方法进行重新编写，得到自己的实现过程。</p><ul><li>返回值类型不变，可以是原返回值类型的子类</li><li>参数列表不变</li><li>访问级别的权限不能比原方法的权限更低</li><li>不能抛出新的检查性异常或比原方法更宽泛的异常</li><li>声明为 <code>final</code> 的方法不能被重写</li><li>声明为 <code>static</code> 的方法不能被重写</li><li>同一包中，子类不能重写父类的 <code>private</code> 和 <code>final</code> 方法</li><li>不同包中，子类只能重写父类的 非 final 的 public 和 protected 方法</li><li>构造方法不能被重写</li><li>使用 <code>super</code> 关键字调用父类中的原方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重载 VS 重写&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>序列化和反序列化</title>
    <link href="https://crowzf.com/posts/83d613f6/"/>
    <id>https://crowzf.com/posts/83d613f6/</id>
    <published>2018-04-12T03:14:24.000Z</published>
    <updated>2018-04-17T05:59:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p><a id="more"></a><p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p><p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p><p>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。<br>ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：<br>public final void writeObject(Object x) throws IOException</p><p>上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：<br>public final Object readObject() throws IOException, ClassNotFoundException</p><p>该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。</p><p>为了演示序列化在Java中是怎样工作的，我将使用之前教程中提到的Employee类，假设我们定义了如下的Employee类，该类实现了Serializable 接口。</p><h2 id="Employee-java-文件代码："><a href="#Employee-java-文件代码：" class="headerlink" title="Employee.java 文件代码："></a>Employee.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> SSN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mailing a check to "</span> + name + <span class="string">" "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类的对象要想序列化成功，必须满足两个条件：</p><ul><li>该类必须实现 java.io.Serializable 对象。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的(transient)。短暂的属性在反序列化时，其值变为类型的默认值。</li></ul><p>如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。</p><hr><h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><p>ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。</p><p>该程序执行后，就创建了一个名为 employee.ser 的文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。<br>注意： 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。</p><h2 id="SerializeDemo-java-文件代码："><a href="#SerializeDemo-java-文件代码：" class="headerlink" title="SerializeDemo.java 文件代码："></a>SerializeDemo.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    </span><br><span class="line">        e.name = <span class="string">"Reyan Ali”;</span></span><br><span class="line"><span class="string">        e.address = "</span>Phokka Kuan, Ambehta Peer”;</span><br><span class="line">        e.SSN = <span class="number">11122333</span>;</span><br><span class="line">        e.number = <span class="number">101</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/employee.ser"</span>);</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br><span class="line">            </span><br><span class="line">            out.writeObject(e);</span><br><span class="line">            </span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            </span><br><span class="line">            System.out.printf(<span class="string">"Serialized data is saved in /tmp/employee.ser"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i) &#123; i.printStackTrace(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="反序列化对象"><a href="#反序列化对象" class="headerlink" title="反序列化对象"></a>反序列化对象</h2><p>下面的 DeserializeDemo 程序实例了反序列化，/tmp/employee.ser 存储了 Employee 对象。</p><h2 id="DeserializeDemo-java-文件代码："><a href="#DeserializeDemo-java-文件代码：" class="headerlink" title="DeserializeDemo.java 文件代码："></a>DeserializeDemo.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Employee e = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/employee.ser"</span>);</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">        </span><br><span class="line">        e = (Employee) in.readObject();</span><br><span class="line">        </span><br><span class="line">        in.close();</span><br><span class="line">        fileIn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException c) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">        c.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Deserialized Employee..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"Name: "</span> + e.name);</span><br><span class="line">    System.out.println(<span class="string">"Address: "</span> + e.address);</span><br><span class="line">    System.out.println(<span class="string">"SSN: "</span> + e.SSN);</span><br><span class="line">    System.out.println(<span class="string">"Number: "</span> + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序编译运行结果如下所示：</p><blockquote><p>Deserialized Employee…<br>Name: Reyan Ali<br>Address:Phokka Kuan, Ambehta Peer<br>SSN: 0<br>Number:101</p></blockquote><ul><li>反序列化不会调用构造器，防止属性被初始化</li><li>如果对象的继承树上有某个类是不可序列化的，该不可序列化类及继承树向上所有类的构造器会被调用</li><li><p>readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p></li><li><p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p></li><li><p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>方法</title>
    <link href="https://crowzf.com/posts/ad01bc3e/"/>
    <id>https://crowzf.com/posts/ad01bc3e/</id>
    <published>2018-04-12T02:32:21.000Z</published>
    <updated>2018-04-17T06:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 方法</p><a id="more"></a><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><ul><li>方法名</li><li>参数类型</li><li>（注意，不包含返回类型）</li><li>不包括参数名称</li></ul><hr><h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><ul><li>参数个数</li><li>参数类型</li><li>参数顺序</li></ul><hr><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>栈帧不会被线程共享，也就是说当前栈帧中存在的对象就可以判定为是不会回收的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Object类</title>
    <link href="https://crowzf.com/posts/351cfb72/"/>
    <id>https://crowzf.com/posts/351cfb72/</id>
    <published>2018-04-12T02:28:16.000Z</published>
    <updated>2018-04-17T05:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>Object 类的公用方法</p><a id="more"></a><h1 id="公用方法："><a href="#公用方法：" class="headerlink" title="公用方法："></a>公用方法：</h1><ul><li><p><code>boolean equals(Object otherObject)</code><br>检测两个对象是否指向同一块存储区域。<br>该方法是非常重要的一个方法。 <em>一般equals和==是不一样的，但是在Object中两者是一样的</em> 。子类、自定义的类中一般都要重写这个方法。</p></li><li><p><code>.clone()</code><br>对象拷贝<br>保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。</p></li><li><code>Class getClass()</code><br>返回和当前对象相关的 Class 对象<br>final 方法，获得运行时类型</li><li><code>.notify()</code><br><code>.notifyally()</code><br>对给定对象进行线程同步</li><li><code>String toString()</code><br>返回描述该对象值的字符串，在自定义的类中，应该重写这个方法。</li><li><code>.hashCode()</code><br>哈希查找，可以减少在查找中使用 equals 的次数，重写了 equals 的方法一般都要重写 hashCode 方法。<br>这个方法在一些具有哈希功能的 Collection 中用到。<br>一般必须满足 <code>obj1.equals(obj2) == true</code>。可以推出 <code>obj1.hashCode() == obj2.hashCode()</code>，但是hashCode相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。<br>如果不重写 hashcode()，在 HashSet 中添加两个 equals 的对象，会将两个对象都加入进去。</li><li><code>.wait()</code><br><code>.wait()</code> 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。<br>线程会释放对象锁<br><code>.wait()</code> 方法一直等待，直到获得锁或者被中断。<br><code>.wait(long timeout)</code> 设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。<br>（1）其他线程调用了该对象的 <code>.notify()</code> 方法。<br>（2）其他线程调用了该对象的 <code>.notifyAll()</code> 方法。<br>（3）其他线程调用了 interrupt 中断该线程。<br>（4）时间间隔到了。<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException 异常。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object 类的公用方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="https://crowzf.com/posts/28877bf/"/>
    <id>https://crowzf.com/posts/28877bf/</id>
    <published>2018-04-12T02:28:11.000Z</published>
    <updated>2018-04-17T05:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>异常的分类与处理</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。<br>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 <code>java.lang.Error</code>；如果你用 <code>System.out.println(11/0)</code> ，那么你是因为你用0做了除数，会抛出 <code>java.lang.ArithmeticException</code> 的异常。</p><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者 JVM 内存溢出。</li><li>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</li></ul><p>要理解 Java 异常处理是如何工作的，你需要掌握以下三种类型的异常：</p><p>检查性异常<br>:    最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p><p>运行时异常<br>:    运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</p><p>错误<br>:    错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p><hr><h1 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h1><p>所有的异常类是从 <code>java.lang.Exception</code> 类继承的子类。<br><code>Exception</code> 类是 <code>Throwable</code> 类的子类。除了 <code>Exception</code> 类外，<code>Throwable</code> 还有一个子类 <code>Error</code> 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在 Java 程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：<code>IOException</code> 类和 <code>RuntimeException</code> 类。</p><p><img src="https://leanote.com/api/file/getImage?fileId=5aaa4d43ab644125360028fc" alt=""></p><p>在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。</p><hr><h1 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h1><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p><p><code>ArithmeticException</code><br>:    当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</p><p><code>ArrayIndexOutOfBoundsException</code><br>:    用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</p><p><code>ArrayStoreException</code><br>:    试图将错误类型的对象存储到一个对象数组时抛出的异常。</p><p><code>ClassCastException</code><br>:    当试图将对象强制转换为不是实例的子类时，抛出该异常。</p><p><code>IllegalArgumentException</code><br>:    抛出的异常表明向方法传递了一个不合法或不正确的参数。</p><p><code>IllegalMonitorStateException</code><br>:    抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</p><p><code>IllegalStateException</code><br>:    在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</p><p><code>IllegalThreadStateException</code><br>:    线程没有处于请求操作所要求的适当状态时抛出的异常。</p><p><code>IndexOutOfBoundsException</code><br>:    指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</p><p><code>NegativeArraySizeException</code><br>:    如果应用程序试图创建大小为负的数组，则抛出该异常。</p><p><code>NullPointerException</code><br>:    当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><p><code>NumberFormatException</code><br>:    当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p><p><code>SecurityException</code><br>:    由安全管理器抛出的异常，指示存在安全侵犯。</p><p><code>StringIndexOutOfBoundsException</code><br>:    此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</p><p><code>UnsupportedOperationException</code><br>:    当不支持请求的操作时，抛出该异常。</p><p><strong>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</strong></p><p><code>ClassNotFoundException</code><br>:    应用程序试图加载类时，找不到相应的类，抛出该异常。</p><p><code>CloneNotSupportedException</code><br>:    当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</p><p><code>IllegalAccessException</code><br>:    拒绝访问一个类的时候，抛出该异常。</p><p><code>InstantiationException</code><br>:    当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</p><p><code>InterruptedException</code><br>:     一个线程被另一个线程中断，抛出该异常。NoSuchFieldException请求的变量不存在NoSuchMethodException请求的方法不存在</p><hr><h1 id="异常方法"><a href="#异常方法" class="headerlink" title="异常方法"></a>异常方法</h1><p>下面的列表是 Throwable 类的主要方法:</p><p><code>.public String getMessage()</code><br>:    返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</p><p><code>.public Throwable getCause()</code><br>:    返回一个Throwable 对象代表异常原因。<br><code>.public String toString()</code><br>:    使用getMessage()的结果返回类的串级名字。</p><p><code>.public void printStackTrace()</code><br>:    打印toString()结果和栈层次到System.err，即错误输出流。</p><p><code>.public StackTraceElement [] getStackTrace()</code><br>:    返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</p><p><code>.public Throwable fillInStackTrace()</code><br>:    用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</p><hr><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。<br>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(ExceptionName e1) &#123;</span><br><span class="line">    <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。<br>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><p> <strong>实例</strong></p><p>下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。</p><h2 id="ExcepTest-java-文件代码："><a href="#ExcepTest-java-文件代码：" class="headerlink" title="ExcepTest.java 文件代码："></a>ExcepTest.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名 : ExcepTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            System.out.println(<span class="string">"Access element three :"</span> + a[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception thrown :"</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Out of the block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码编译运行输出结果如下：</p><blockquote><p>Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3<br>Out of the block</p></blockquote><hr><h2 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h2><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。<br>多重捕获块的语法如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>该实例展示了怎么使用多重 try/catch。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException i)&#123;</span><br><span class="line">    i.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException f) <span class="comment">//Not valid! &#123; </span></span><br><span class="line">    f.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## throws/throw 关键字：</span><br><span class="line"></span><br><span class="line">如果一个方法没有捕获一个检查性异常，那么该方法必须使用 `<span class="keyword">throws</span>` 关键字来声明。`<span class="keyword">throws</span>` 关键字放在方法签名的尾部。</span><br><span class="line"></span><br><span class="line">也可以使用 `<span class="keyword">throw</span>` 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</span><br><span class="line">下面方法的声明抛出一个 RemoteException 异常：</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="comment">// Method implementation</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。<br>例如，下面的方法声明抛出 <code>RemoteException</code> 和 <code>InsufficientFundsException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException, InsufficientFundsException </span>&#123;</span><br><span class="line">        <span class="comment">// Method implementation</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a><code>finally</code>关键字</h2><p><code>finally</code> 关键字用来创建在 <code>try</code> 代码块后面执行的代码块。</p><p>无论是否发生异常，<code>finally</code> 代码块中的代码总会被执行。</p><p>在 <code>finally</code> 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p><code>finally</code> 代码块出现在 <code>catch</code> 代码块最后，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h2 id="ExcepTest-java-文件代码：-1"><a href="#ExcepTest-java-文件代码：-1" class="headerlink" title="ExcepTest.java 文件代码："></a>ExcepTest.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcepTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Access element three :"</span> + a[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception thrown :"</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            a[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">            System.out.println(<span class="string">"First element value: "</span> +a[<span class="number">0</span>]);</span><br><span class="line">            System.out.println(<span class="string">"The finally statement is executed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><blockquote><p>Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3<br>First element value: 6<br>The finally statement is executed</p></blockquote><p>注意下面事项：<br><code>catch</code> 不能独立于 <code>try</code> 存在。<br>在 <code>try/catch</code> 后面添加 <code>finally</code> 块并非强制性要求的。<br><code>try</code> 代码后不能既没 <code>catch</code> 块也没 <code>finally</code> 块。</p><h2 id="try-catch-finally-块之间不能添加任何代码。"><a href="#try-catch-finally-块之间不能添加任何代码。" class="headerlink" title="try, catch, finally 块之间不能添加任何代码。"></a><code>try</code>, <code>catch</code>, <code>finally</code> 块之间不能添加任何代码。</h2><h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><p>所有异常都必须是 <code>Throwable</code> 的子类。<br>如果希望写一个检查性异常类，则需要继承 <code>Exception</code> 类。<br>如果你想写一个运行时异常类，那么需要继承 <code>RuntimeException</code> 类。<br>可以像下面这样定义自己的异常类：</p><p><code>class MyException extends Exception{}</code></p><p>只继承 <code>Exception</code> 类来创建的异常类是检查性异常类。<br>下面的 <code>InsufficientFundsException</code> 类是用户定义的异常类，它继承自 <code>Exception</code>。<br>一个异常类和其它任何类一样，包含有变量和方法。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。</p><h2 id="InsufficientFundsException-java-文件代码："><a href="#InsufficientFundsException-java-文件代码：" class="headerlink" title="InsufficientFundsException.java 文件代码："></a>InsufficientFundsException.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名InsufficientFundsException.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常类，继承Exception类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsufficientFundsException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsufficientFundsException</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了展示如何使用我们自定义的异常类，<br>在下面的 <code>CheckingAccount</code> 类中包含一个 <code>withdraw()</code> 方法抛出一个 <code>InsufficientFundsException</code> 异常。</p><h2 id="CheckingAccount-java-文件代码："><a href="#CheckingAccount-java-文件代码：" class="headerlink" title="CheckingAccount.java 文件代码："></a>CheckingAccount.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名称 CheckingAccount.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此类模拟银行账户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckingAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//balance为余额，number为卡号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheckingAccount</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：取钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt;= balance) &#123;</span><br><span class="line">            balance -= amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> needs = amount - balance;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException(needs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：返回余额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法：返回卡号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。</p><h2 id="BankDemo-java-文件代码："><a href="#BankDemo-java-文件代码：" class="headerlink" title="BankDemo.java 文件代码："></a>BankDemo.java 文件代码：</h2><p>//文件名称 BankDemo.java</p><p>public class BankDemo{</p><pre><code>public static void main(String [] args) {    CheckingAccount c = new CheckingAccount(101);    System.out.println(&quot;Depositing $500...&quot;);    c.deposit(500.00);    try {        System.out.println(&quot;\nWithdrawing $100...&quot;);        c.withdraw(100.00);        System.out.println(&quot;\nWithdrawing $600...&quot;);        c.withdraw(600.00);    } catch(InsufficientFundsException e) {        System.out.println(&quot;Sorry, but you are short $&quot; + e.getAmount());        e.printStackTrace();    }}</code></pre><p>}</p><p>编译上面三个文件，并运行程序 BankDemo，得到结果如下所示：</p><blockquote><p>Depositing $500…<br>Withdrawing $100…<br>Withdrawing $600…<br>Sorry, but you are short $200.0<br>InsufficientFundsException<br>at CheckingAccount.withdraw(CheckingAccount.java:25)<br>at BankDemo.main(BankDemo.java:13)</p></blockquote><hr><h2 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h2><p>在Java中定义了两种类型的异常和错误。<br>JVM(Java虚拟机) 异常<br>：    由 JVM 抛出的异常或错误。例如：<code>NullPointerException</code> 类，<code>ArrayIndexOutOfBoundsException</code> 类，<code>ClassCastException</code> 类。<br>程序级异常<br>：    由程序或者API程序抛出的异常。例如 <code>IllegalArgumentException</code> 类，<code>IllegalStateException</code> 类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常的分类与处理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashCode</title>
    <link href="https://crowzf.com/posts/600c4239/"/>
    <id>https://crowzf.com/posts/600c4239/</id>
    <published>2018-04-12T02:27:59.000Z</published>
    <updated>2018-04-17T05:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，哈希码是对象的一种标记符，有时可以用来区分对象，就像是门牌号一样。</p><a id="more"></a><h2 id="HashCode的特性"><a href="#HashCode的特性" class="headerlink" title="HashCode的特性"></a>HashCode的特性</h2><p>（1）HashCode的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，HashCode 经常用于确定对象的存储地址。<br>（2）两个对象相同，则 <code>.equals()</code> 方法返回 true ，HashCode 相同。<br>（3）两个对象的 HashCode 相同，两个对象却不一定相同， <code>.equals()</code> 不一定为 true。<br>（4）如果对象的 <code>.equals()</code> 方法被重写，那么对象的 HashCode 也尽量重写。</p><hr><h2 id="HashCode作用"><a href="#HashCode作用" class="headerlink" title="HashCode作用"></a>HashCode作用</h2><p>Java中的集合有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 </p><p><code>.equals()</code> 方法可用于保证元素不重复，但如果每增加一个元素就检查一次，若集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次 <code>.equals()</code> 方法。这显然会大大降低效率。 于是，Java 采用了哈希表的原理。</p><p>哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。<br>这样一来，当集合要添加新的元素时，先调用这个元素的 HashCode 方法，就一下子能定位到它应该放置的物理位置上。</p><p>（1）如果这个位置上没有元素，它就可以直接存储在这个位置上；<br>（2）如果这个位置上已经有元素了，就调用它的 <code>.equals()</code> 方法与新元素进行比较，相同的话就不存了，散列到其他地址上；<br>（3）（HashCode 相同，<code>.equals()</code> 的结果）不相同的话，也就是发生了Hash key 相同导致冲突的情况，那么就在这个 Hash key 的地方产生一个链表，将所有产生相同 HashCode 的对象放到这个单链表上去，串在一起（很少出现）。这样一来实际调用 <code>.equals()</code> 方法的次数就大大降低了，几乎只需要一两次。 </p><p>从 Object 角度看，JVM 每 <code>new</code> 一个 Object，它都会将这个 Object 丢到一个 Hash 表中去，这样的话，下次做 Object 的比较或者取这个对象的时候（读取过程），它会根据对象的 HashCode 再从 Hash 表中取这个对象。这样做的目的是提高取对象的效率。若 HashCode 相同再去调用 <code>.equals()</code>。</p><hr><h2 id="HashCode实践"><a href="#HashCode实践" class="headerlink" title="HashCode实践"></a>HashCode实践</h2><p>HashCode 是用于查找使用的，而 <code>.equals()</code> 是用于比较两个对象是否相等的。</p><p>例如内存中有这样的位置 ：<br><code>0  1  2  3  4  5  6  7</code><br>而我有个类，这个类有个字段叫ID，我要把这个类存放在以上8个位置之一，如果不用 HashCode 而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。  </p><p>但以上问题如果用 HashCode 就会使效率提高很多。  定义我们的 HashCode 为 ID％8，比如我们的 ID 为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果 ID 是13，求得的余数是5，那么我们就把该类放在5这个位置。依此类推。  </p><p>但是如果两个类有相同的 HashCode ，例如9除以8和17除以8的余数都是1，也就是说，我们先通过 HashCode 来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 <code>.equals()</code> 在这个桶里找到我们要的类。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTest</span> </span>&#123;    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> i;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;    </span><br><span class="line"><span class="keyword">this</span>.i = i;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="keyword">return</span> i % <span class="number">10</span>;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">HashTest a = <span class="keyword">new</span> HashTest();    </span><br><span class="line">HashTest b = <span class="keyword">new</span> HashTest();    </span><br><span class="line">a.setI(<span class="number">1</span>);    </span><br><span class="line">b.setI(<span class="number">1</span>);    </span><br><span class="line">Set&lt;HashTest&gt; set = <span class="keyword">new</span> HashSet&lt;HashTest&gt;();    </span><br><span class="line">set.add(a);    </span><br><span class="line">set.add(b);    </span><br><span class="line">System.out.println(a.hashCode() == b.hashCode());    </span><br><span class="line">System.out.println(a.equals(b));    </span><br><span class="line">System.out.println(set);    </span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>true<br>false  </p></blockquote><p>以上这个示例，我们只是重写了 HashCode 方法，从上面的结果可以看出，虽然两个对象的 HashCode 相等，但是实际上两个对象并不是相等，因为我们没有重写 <code>.equals()</code> 方法，那么就会调用 Object 默认的 <code>.equals()</code> 方法，显示这是两个不同的对象。</p><p>这里我们将生成的对象放到了 HashSet 中，而 HashSet 中只能够存放唯一的对象，也就是相同的（适用于 <code>.equals()</code> 方法）的对象只会存放一个，但是这里实际上是两个对象ab都被放到了 HashSet 中，这样 HashSet 就失去了他本身的意义了。</p><p>下面我们继续重写equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTest</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.i = i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">this</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> HashTest)) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        HashTest other = (HashTest) object;    </span><br><span class="line">        <span class="keyword">if</span> (other.getI() == <span class="keyword">this</span>.getI()) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">10</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        HashTest a = <span class="keyword">new</span> HashTest();    </span><br><span class="line">        HashTest b = <span class="keyword">new</span> HashTest();    </span><br><span class="line">        a.setI(<span class="number">1</span>);    </span><br><span class="line">        b.setI(<span class="number">1</span>);    </span><br><span class="line">        Set&lt;HashTest&gt; set = <span class="keyword">new</span> HashSet&lt;HashTest&gt;();    </span><br><span class="line">        set.add(a);    </span><br><span class="line">        set.add(b);    </span><br><span class="line">        System.out.println(a.hashCode() == b.hashCode());    </span><br><span class="line">        System.out.println(a.equals(b));    </span><br><span class="line">        System.out.println(set);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示。<br>从结果我们可以看出，现在两个对象就完全相等了，HashSet中也只存放了一份对象。</p><blockquote><p>true<br>true  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，哈希码是对象的一种标记符，有时可以用来区分对象，就像是门牌号一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>字符串 String 类型</title>
    <link href="https://crowzf.com/posts/fc81fbfd/"/>
    <id>https://crowzf.com/posts/fc81fbfd/</id>
    <published>2018-04-12T02:27:46.000Z</published>
    <updated>2018-04-17T05:59:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>String类，StringBuffer与StringBuilder的区别</p><a id="more"></a><h2 id="字符串-String类"><a href="#字符串-String类" class="headerlink" title="字符串 String类"></a>字符串 String类</h2><ul><li>不可变的，不能修改。以便于编译器可以实现字符串共享</li><li>通过提取子串再拼接新串的方法间接修改。</li><li>检测字符串相等使用<code>s.equals(t)</code>方法</li><li>不区分大小写检测字符串相等使用 <code>s.equalsIgnoreCase(t)</code> 方法</li><li>不能用 <code>==</code> 检测字符串是否相等。<code>==</code> 只检测两个字符串是否在内存的同一个位置上。<code>.equals()</code> 检测二者在内存中的值是否相同。</li><li><code>.length()</code> 方法返回字符串所需的代码单元数量</li><li><code>.codePointCound(0, s.length())</code> 返回码点数量，即实际长度。</li><li><code>.charAt(n)</code> 返回位置 n 的代码单元</li></ul><hr><h2 id="String、StringBuffer与StringBuilder的区别"><a href="#String、StringBuffer与StringBuilder的区别" class="headerlink" title="String、StringBuffer与StringBuilder的区别"></a>String、StringBuffer与StringBuilder的区别</h2><ul><li>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象</li><li>StringBuffer 和 StringBuilder 底层是 char[] 实现的</li><li>StringBuffer 是线程安全的，而 StringBuilder 是线程不安全的</li><li>StringBuilder 比 StringBuffer 有速度优势</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String类，StringBuffer与StringBuilder的区别&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>整数溢出</title>
    <link href="https://crowzf.com/posts/704e6497/"/>
    <id>https://crowzf.com/posts/704e6497/</id>
    <published>2018-04-12T02:27:37.000Z</published>
    <updated>2018-04-17T06:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>整数溢出的原理以及解决方法</p><a id="more"></a><p>Java 中的 int 总共就 32 位，正数上限的情况首位也只能是 0，其他位都可以是 1（就是 2^31-1 的情况）。但是如果正数过大了，例如 2^31，计算机不得不把首位变成 1，并且很快就忘了这是溢出情况，把它按照正常的方式输出了，于是就成了负的。其实也不能怪它，它没有办法自动处理超过溢出的情况，因为 32 位是固定的，它不能因为溢出而临时扩展到 33 位之类的。</p><p>防止溢出的办法是无符号右移一位？？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整数溢出的原理以及解决方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>堆栈</title>
    <link href="https://crowzf.com/posts/af55460a/"/>
    <id>https://crowzf.com/posts/af55460a/</id>
    <published>2018-04-12T02:27:15.000Z</published>
    <updated>2018-04-17T05:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 内存</p><a id="more"></a><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><ul><li>存取速度快</li><li>局部变量</li><li>方法栈区内的引用变量</li><li>基本类型变量</li></ul><hr><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><ul><li>new 创建的对象（包括作为对象的值的基本类型变量）和数组</li><li>对象在堆内存中不一定是连续的内存，可能是零散的堆内存地址。通过哈希算法换算出一长串哈希数字来表征其在内存中的“物理位置”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 内存&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>源文件的声明规则</title>
    <link href="https://crowzf.com/posts/63441ac3/"/>
    <id>https://crowzf.com/posts/63441ac3/</id>
    <published>2018-04-12T02:27:01.000Z</published>
    <updated>2018-04-17T06:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>源文件声明时的习惯</p><a id="more"></a><p>当在一个源文件中定义多个类，并且还有<code>import</code>语句和<code>package</code>语句时，要特别注意这些规则。</p><ul><li>一个源文件中<strong>只能有一个</strong><code>public</code>类</li><li>一个源文件可以有多个非<code>public</code>类</li><li>源文件的名称应该和<code>public类</code>的类名保持一致。</li><li>如果一个类定义在某个包中，那么<code>package</code>语句应该在源文件的首行。</li><li>如果源文件包含<code>import</code>语句，那么应该放在<code>package</code>语句和类定义之间。如果没有<code>package</code>语句，那么import语句应该在源文件中最前面。</li><li><code>import</code>语句和<code>package</code>语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li><li>类有若干种访问级别，并且类也分不同的类型：抽象类和<code>final</code>类等。</li></ul><p>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源文件声明时的习惯&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>修饰符</title>
    <link href="https://crowzf.com/posts/9cc58f5a/"/>
    <id>https://crowzf.com/posts/9cc58f5a/</id>
    <published>2018-04-12T02:26:51.000Z</published>
    <updated>2018-04-17T05:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>非访问控制修饰符与访问控制修饰符</p><a id="more"></a><h2 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符 :"></a>非访问控制修饰符 :</h2><table><thead><tr><th>final</th><th>不可重写，不可更改（不可重新赋值）</th></tr></thead><tbody><tr><td>abstract</td><td>抽象</td></tr><tr><td>strictfp</td></tr></tbody></table><hr><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><table><thead><tr><th style="text-align:center">当前类</th><th style="text-align:center">同包</th><th style="text-align:center">子类</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td>√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td>×</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td>×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td>×</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;非访问控制修饰符与访问控制修饰符&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="https://crowzf.com/posts/15fc6e8c/"/>
    <id>https://crowzf.com/posts/15fc6e8c/</id>
    <published>2018-04-12T02:26:48.000Z</published>
    <updated>2018-04-19T10:18:30.368Z</updated>
    
    <content type="html"><![CDATA[<p>线程（thread）是操作系统能够进行<strong>运算调度</strong>的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 </p><a id="more"></a><ol><li>创建 <code>Runnable</code> 对象（“工作”）<br><code>Runnable</code> 是一个接口。写一个类实现该接口，在这个类中定义线程要做的事。<br><code>Runnable threadJob = new MyRunnable();</code></li><li>创建一个 Thread 对象（“工人”），给它分配 Runnable 对象（“工作”）(NEW 状态)<br><code>Thread myThread = new Thread(threadJob);</code></li><li>开始该线程，创建新的栈内存给线程(<code>Runnable</code> 状态)<br><code>myThread.start();</code><br>线程变为 Runnable 状态后，可以在 Runnable, Running 两种状态中转换，Running 状态还可以转换为 Blocked 状态。<br>JVM 的线程管理器似乎是混乱的，无法期待其安排出明确的线程运行顺序（并发问题），因此程序的正确性不应基于线程管理器运行线程的顺序。</li></ol><p>并发问题的发生源于两个或更多线程访问同一（实现 <code>Runnable</code> 的类型的）对象的数据。</p><ul><li>A 线程访问数据，检查数据，准备操作数据时，进入 <code>sleep()</code></li><li>B 线程访问数据，检查数据，对数据进行操作。</li><li>A 线程醒来，不知道自己 <code>sleep()</code> ，未检查数据，直接对数据进行操作。</li></ul><p>使用静态方法 <code>sleep()</code> 方法可以确保线程在持续时间内不被转换为 Running。使其他线程可以运行。</p><p>解决并发问题—— <code>synchronized</code> 标识符：<br>被 synchronized 标记的方法，在同一时间内只允许一个线程进入并运行完整个方法。运行过程中其它线程不允许进入。</p><p><code>sleep()</code> 方法会抛出 InterruptedException 异常（检查性异常）。所有调用 <code>sleep()</code> 方法必须被包裹在 try/catch 中。或直接声明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从 <code>sleep()</code> 中恢复过来的线程会处于 <code>Runnable</code> 状态。</p><hr><h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。<br>下图显示了一个线程完整的生命周期。</p><p><img src="https://i.imgur.com/iSH9RG0.png" alt="Imgur"></p><ul><li><strong>新建状态(New):</strong><br>使用 <code>new</code> 关键字和 <code>Thread</code> 类或其子类建立一个线程对象后，该线程对象就处于 New 状态。它保持这个状态直到程序 <code>start()</code> 这个线程。</li><li><strong>就绪状态(Runnable):</strong><br>当线程对象调用了 <code>start()</code> 方法之后，该线程就进入 Runnable 状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。</li><li><strong>运行状态(Running):</strong><br>如果就绪状态的线程获取 CPU 资源，就可以执行 <code>run()*</code> ，此时线程便处于Running 。处于运行状态的线程最为复杂，它可以变为 Blocked 、Runnable 和 Dead。</li><li><strong>阻塞状态(Block):</strong><br>如果一个线程执行了 <code>sleep()</code>（睡眠）、<code>suspend()</code>（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入 Block 状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：<ul><li>等待阻塞：运行状态中的线程执行 <code>wait()</code> 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 <code>synchronized</code> 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 <code>sleep()</code> 或 <code>join()</code> 发出了 I/O 请求时，线程就会进入到阻塞状态。当 <code>sleep()</code> 状态超时，<code>join()</code> 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><strong>死亡状态:</strong><br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</li></ul><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。<br>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。<br>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。<h3 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h3>创建一个线程，最简单的方法是创建一个实现 <code>Runnable</code> 接口的类。<br>为了实现 <code>Runnable</code>，一个类只需要执行一个方法调用 <code>run()</code>，声明如下：<br>你可以重写该方法，重要的是理解的 <code>run()</code> 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</li></ul><p>在创建一个实现 <code>Runnable</code> 接口的类之后，你可以在类中实例化一个线程对象。<br>Thread 定义了几个构造方法，下面的这个是我们经常使用的：<br><code>Thread(Runnable threadOb,String threadName);</code><br>这里，<code>threadOb</code> 是一个实现 <code>Runnable</code> 接口的类的实例，并且 <code>threadName</code> 指定新线程的名字。<br>新线程创建之后，你调用它的 <code>start()</code>方法它才会运行。<br>下面是一个创建线程并开始让它执行的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> Thread t; </span><br><span class="line"><span class="keyword">private</span> String threadName;</span><br><span class="line">RunnableDemo(String name) &#123; </span><br><span class="line">threadName = name; </span><br><span class="line">System.out.println(<span class="string">"Creating "</span> + threadName); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"Running "</span> + threadName ); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">System.out.println(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);  </span><br><span class="line">Thread.sleep(<span class="number">50</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" interrupted."</span>); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" exiting."</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"Starting "</span> + threadName ); </span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName); </span><br><span class="line">t.start (); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">RunnableDemo R1 = <span class="keyword">new</span> RunnableDemo( <span class="string">"Thread-1"</span>); </span><br><span class="line">R1.start(); </span><br><span class="line">RunnableDemo R2 = <span class="keyword">new</span> RunnableDemo( <span class="string">"Thread-2"</span>); </span><br><span class="line">R2.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h2><p>创建一个线程的第二种方法是创建一个新的类，该类继承 <code>Thread</code> 类，然后创建一个该类的实例。<br>继承类必须重写 <code>run()</code> 方法，该方法是新线程的入口点。它也必须调用 <code>start()</code> 方法才能执行。<br>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> Thread t; </span><br><span class="line"><span class="keyword">private</span> String threadName; </span><br><span class="line">ThreadDemo(String name) &#123; </span><br><span class="line">threadName = name; </span><br><span class="line">System.out.println(<span class="string">"Creating "</span> + threadName ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"Running "</span> + threadName ); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &gt; <span class="number">0</span>; i--) &#123; </span><br><span class="line">System.out.println(<span class="string">"Thread: "</span> + threadName + <span class="string">", "</span> + i);  </span><br><span class="line">Thread.sleep(<span class="number">50</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" interrupted."</span>); </span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">"Thread "</span> + threadName + <span class="string">" exiting."</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">System.out.println(<span class="string">"Starting "</span> + threadName ); </span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">t = <span class="keyword">new</span> Thread (<span class="keyword">this</span>, threadName); </span><br><span class="line">t.start (); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">ThreadDemo T1 = <span class="keyword">new</span> ThreadDemo( <span class="string">"Thread-1"</span>); </span><br><span class="line">T1.start(); </span><br><span class="line">ThreadDemo T2 = <span class="keyword">new</span> ThreadDemo( <span class="string">"Thread-2"</span>); </span><br><span class="line">T2.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Thread-方法"><a href="#Thread-方法" class="headerlink" title="Thread 方法"></a>Thread 方法</h2><p>下表列出了Thread类的一些重要方法：</p><ul><li><code>public void start()</code><br>使该线程开始执行； Java 虚拟机调用该线程的 <code>run()</code> 方法。    </li><li><code>public void run()</code><br>如果该线程是使用独立的 <code>Runnable</code> 运行对象构造的，则调用该 <code>Runnable</code> 对象的 <code>run()</code> 方法；否则，该方法不执行任何操作并返回。    </li><li><code>public final void setName(String name)</code><br>改变线程名称，使之与参数 <code>name</code> 相同。    </li><li><code>public final void setPriority(int priority)</code><br>更改线程的优先级。    </li><li><code>public final void setDaemon(boolean on)</code><br>将该线程标记为守护线程或用户线程。 </li><li><code>public final void join(long millisec)</code><br>等待该线程终止的时间最长为 <code>millis</code> 毫秒。    </li><li><code>public void interrupt()</code><br>中断线程。    </li><li><code>public final boolean isAlive()</code><br>测试线程是否处于活动状态。</li></ul><p>上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p><ul><li><code>public static void yield()</code><br>暂停当前正在执行的线程对象，并执行其他线程。    </li><li><code>public static void sleep(long millisec)</code><br>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。<br>线程不会释放对象锁</li><li><code>public static boolean holdsLock(Object x)</code><br>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 <code>true</code>。    </li><li><code>public static Thread currentThread()</code><br>返回对当前正在执行的线程对象的引用。  </li><li><code>public static void dumpStack()</code><br>将当前线程的堆栈跟踪打印至标准错误流。</li></ul><hr><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayMessage</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> String message; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayMessage</span><span class="params">(String message)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.message = message; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line">System.out.println(message); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessANumber</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GuessANumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.number = number; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> guess = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">guess = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span> + <span class="number">1</span>); </span><br><span class="line">System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" guesses "</span> + guess); counter++; </span><br><span class="line">&#125; <span class="keyword">while</span>(guess != number); </span><br><span class="line">System.out.println(<span class="string">"** Correct!"</span> + <span class="keyword">this</span>.getName() + <span class="string">"in"</span> + counter + <span class="string">"guesses.**"</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadClassDemo</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123; </span><br><span class="line">Runnable hello = <span class="keyword">new</span> DisplayMessage(<span class="string">"Hello"</span>); </span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(hello); </span><br><span class="line">thread1.setDaemon(<span class="keyword">true</span>); </span><br><span class="line">thread1.setName(<span class="string">"hello"</span>); </span><br><span class="line">System.out.println(<span class="string">"Starting hello thread..."</span>); </span><br><span class="line">thread1.start(); </span><br><span class="line">Runnable bye = <span class="keyword">new</span> DisplayMessage(<span class="string">"Goodbye"</span>); </span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(bye); </span><br><span class="line">thread2.setPriority(Thread.MIN_PRIORITY); </span><br><span class="line">thread2.setDaemon(<span class="keyword">true</span>); </span><br><span class="line">System.out.println(<span class="string">"Starting goodbye thread..."</span>); </span><br><span class="line">thread2.start(); </span><br><span class="line">System.out.println(<span class="string">"Starting thread3..."</span>); </span><br><span class="line">Thread thread3 = <span class="keyword">new</span> GuessANumber(<span class="number">27</span>); </span><br><span class="line">thread3.start(); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">thread3.join(); </span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123; </span><br><span class="line">System.out.println(<span class="string">"Thread interrupted."</span>); </span><br><span class="line">&#125; System.out.println(<span class="string">"Starting thread4..."</span>); </span><br><span class="line">Thread thread4 = <span class="keyword">new</span> GuessANumber(<span class="number">75</span>); </span><br><span class="line">thread4.start(); </span><br><span class="line">System.out.println(<span class="string">"main() is ending..."</span>); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，每一次运行的结果都不一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Starting hello thread... Starting goodbye thread... Hello Hello Hello Hello Hello Hello Goodbye Goodbye Goodbye Goodbye Goodbye .......</span><br></pre></td></tr></table></figure><hr><h2 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h2><ol><li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li><li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call()</code> 方法的返回值。</li><li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 <code>target</code> 创建并启动新线程。</li><li>调用 <code>FutureTask</code> 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest(); </span><br><span class="line">FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123; </span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i); </span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">20</span>) &#123; </span><br><span class="line"><span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">try</span> &#123; System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++) &#123; </span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li><ol><li>采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li></ol></li><li><ol start="2"><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 <code>Thread.currentThread()</code> 方法，直接使用 this 即可获得当前线程。</li></ol></li><li>​</li></ul><hr><h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p><ul><li>线程同步</li><li>线程间通信</li><li>线程死锁</li><li>线程控制：挂起、停止和恢复</li></ul><hr><h2 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h2><p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。<br>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。<br>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程（thread）是操作系统能够进行&lt;strong&gt;运算调度&lt;/strong&gt;的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="https://crowzf.com/posts/95495db/"/>
    <id>https://crowzf.com/posts/95495db/</id>
    <published>2018-04-12T02:26:43.000Z</published>
    <updated>2018-04-17T06:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件 I/O 操作</p><a id="more"></a><h2 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h2><p><code>File f = new File(&quot;MyCode.txt&quot;);</code></p><hr><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"Chapter7"</span>);`</span><br><span class="line">dir.mkdir();</span><br></pre></td></tr></table></figure><hr><h2 id="列出文件夹中的内容"><a href="#列出文件夹中的内容" class="headerlink" title="列出文件夹中的内容"></a>列出文件夹中的内容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dir.isDirectory()) &#123;</span><br><span class="line">    String[] dirContents = dir.list();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirContents.length; i++) &#123;</span><br><span class="line">        System.out.println(dirContents[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="得到文件或文件夹的绝对路径"><a href="#得到文件或文件夹的绝对路径" class="headerlink" title="得到文件或文件夹的绝对路径"></a>得到文件或文件夹的绝对路径</h2><p><code>System.out.println(dir.getAbsolutePath());</code></p><hr><h2 id="删除文件或文件夹（成功则返回true）"><a href="#删除文件或文件夹（成功则返回true）" class="headerlink" title="删除文件或文件夹（成功则返回true）**"></a>删除文件或文件夹（成功则返回true）**</h2><p><code>boolean isDeleted = f.delete();</code></p><p>文件对象代表文件或文件夹在磁盘上的文件名和路径，不代表能够访问文件的内容！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件 I/O 操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>位操作</title>
    <link href="https://crowzf.com/posts/6a503052/"/>
    <id>https://crowzf.com/posts/6a503052/</id>
    <published>2018-04-12T02:26:40.000Z</published>
    <updated>2018-04-17T05:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>位操作的概念与应用</p><a id="more"></a><h2 id="位操作基础"><a href="#位操作基础" class="headerlink" title="位操作基础"></a>位操作基础</h2><p>1为真，0为假</p><ul><li>与：<code>&amp;</code> 两个位都为 1 时，结果才为 1</li><li>或：<code>|</code> 两个位都是 0 时，结果才为 0</li><li>异或：<code>^</code> 两个位相同时为 0，相异为 1</li><li>取反：<code>~</code> 0 变 1，1 变 0</li><li>左移：<code>&lt;&lt;</code> 各二进位全部左移若干位，高位丢弃，低位补 0</li><li>右移：<code>&gt;&gt;</code> 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移)，有的补 0 (逻辑右移)</li></ul><hr><ul><li>在这6种操作符，只有 ~ 取反是单目操作符，其它5种都是双目操作符。</li><li>位操作只能用于整形数据，对 <code>float</code> 和 <code>double</code> 类型进行位操作会被编译器报错。</li><li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像 1，3，5，9 这些 2^i+1 的数字。写成 <code>int a = 1 &lt;&lt; i + 1</code>; 是不对的，程序会先执行 i + 1，再执行左移操作。应该写成 <code>int a = (1 &lt;&lt; i) + 1</code>;</li><li>另外位操作还有一些复合操作符，如 &amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;=</li></ul><hr><h2 id="常用位操作小技巧"><a href="#常用位操作小技巧" class="headerlink" title="常用位操作小技巧"></a>常用位操作小技巧</h2><h3 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h3><p>只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。</p><p> <code>if ((a &amp; 1) == 0)</code> </p><h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure><p>可以这样理解：</p><ul><li>第一步 a ^= b 即 a = (a ^ b)；</li><li>第二步 b ^= a 即 b = b ^ ( a ^ b)，由于异或运算满足交换律，b ^ ( a ^ b) = b ^ b ^ a。由于一个数和自己异或的结果为 0 并且任何数与 0 异或都会不变的，所以此时 b 被赋上了 a 的值；</li><li>第三步 a ^= b 就是 a = a ^ b，由于前面二步可知 a = ( a ^ b)，b=a，所以 a = a ^ b 即 a = ( a ^ b ) ^ a。故 a 会被赋上 b 的值。</li></ul><h3 id="变换符号"><a href="#变换符号" class="headerlink" title="变换符号"></a>变换符号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取反后加 1</span></span><br><span class="line"><span class="comment">// 注意计算机以补码表示，因此是对补码取反</span></span><br><span class="line">System.out.println(~a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="求绝对值"><a href="#求绝对值" class="headerlink" title="求绝对值"></a>求绝对值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 是32位，右移31位即可使符号位落入最后一位</span></span><br><span class="line"><span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println(i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>现在再分析下。对于任何数，与 0 异或都会保持不变，与 -1 即 0xFFFFFFFF 异或就相当于取反。因此，a 与 i 异或后再减 i（因为 i 为 0 或 -1，所以减 i即是要么加 0要么加 1）也可以得到绝对值。所以可以对上面代码优化下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">System.out.println((a ^ j) - j);</span><br></pre></td></tr></table></figure><p>注意这种方法没用任何判断表达式.</p><h3 id="位操作与空间压缩"><a href="#位操作与空间压缩" class="headerlink" title="位操作与空间压缩"></a>位操作与空间压缩</h3><p>筛素数(质数)法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[max];</span><br><span class="line"><span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pi = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!flags[m]) &#123;</span><br><span class="line">primes[pi++] = m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">flags[n] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure><p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。</p><h3 id="在数组中把指定位置变为1"><a href="#在数组中把指定位置变为1" class="headerlink" title="在数组中把指定位置变为1"></a>在数组中把指定位置变为1</h3><p>下面考虑下如何在数组中对指定位置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将 1 向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在一个数指定位上置1</span></span><br><span class="line"><span class="keyword">int</span> e = <span class="number">0</span>;</span><br><span class="line">e |= <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line">System.out.println(e);</span><br></pre></td></tr></table></figure><h3 id="判断指定位置是0还是1"><a href="#判断指定位置是0还是1" class="headerlink" title="判断指定位置是0还是1"></a>判断指定位置是0还是1</h3><p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断指定位上是0还是1</span></span><br><span class="line"><span class="keyword">if</span> ((e &amp; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>)) != <span class="number">0</span>)</span><br><span class="line">System.out.println(<span class="string">"指定位上为1"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"指定位上为0"</span>);</span><br></pre></td></tr></table></figure><p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span> / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m += <span class="number">3</span>) &#123;</span><br><span class="line">bits[m / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (m % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出整个bits</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">40</span>; m++) &#123;</span><br><span class="line"><span class="keyword">if</span> (((bits[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">System.out.print(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.print(<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log 信息</p><p>1001001001001001001001001001001001001001</p><p>可以看出该数组每 3 个就置成了1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] flags2 = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> [] primes = <span class="keyword">new</span> <span class="keyword">int</span>[max / <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">pi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt; max ; m ++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((((flags2[m / <span class="number">32</span>] &gt;&gt; (m % <span class="number">32</span>)) &amp; <span class="number">1</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line">primes[pi++] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n = m; n &lt; max; n += m) &#123;</span><br><span class="line">flags2[n / <span class="number">32</span>] |= (<span class="number">1</span> &lt;&lt; (n % <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(primes));</span><br></pre></td></tr></table></figure><p>log 信息为</p><p>[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0]</p><h3 id="获取-int-型最大值"><a href="#获取-int-型最大值" class="headerlink" title="获取 int 型最大值"></a>获取 int 型最大值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于优先级关系，括号不可省略</span></span><br><span class="line">System.out.println((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>);<span class="comment">// 2147483647， </span></span><br><span class="line">System.out.println(~(<span class="number">1</span> &lt;&lt; <span class="number">31</span>));<span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure><h3 id="获取-int-型最小值"><a href="#获取-int-型最小值" class="headerlink" title="获取 int 型最小值"></a>获取 int 型最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 获得int型最小值</span></span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">System.out.println(<span class="number">1</span> &lt;&lt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="获取-long-型最大值"><a href="#获取-long-型最大值" class="headerlink" title="获取 long 型最大值"></a>获取 long 型最大值</h3><p><code>System.out.println(((long)1 &lt;&lt; 127) - 1);</code></p><h3 id="乘以2"><a href="#乘以2" class="headerlink" title="乘以2"></a>乘以2</h3><p><code>System.out.println(10&lt;&lt;1);</code></p><h3 id="除以2（负奇数运算不可用）"><a href="#除以2（负奇数运算不可用）" class="headerlink" title="除以2（负奇数运算不可用）"></a>除以2（负奇数运算不可用）</h3><p><code>System.out.println(10&gt;&gt;1);</code></p><h3 id="乘以-2-的-m-次幂"><a href="#乘以-2-的-m-次幂" class="headerlink" title="乘以 2 的 m 次幂"></a>乘以 2 的 m 次幂</h3><p><code>System.out.println(10&lt;&lt;2);</code></p><h3 id="除以-2-的-m-次幂"><a href="#除以-2-的-m-次幂" class="headerlink" title="除以 2 的 m 次幂"></a>除以 2 的 m 次幂</h3><p><code>System.out.println(16&gt;&gt;2);</code></p><h3 id="判断一个数的奇偶性"><a href="#判断一个数的奇偶性" class="headerlink" title="判断一个数的奇偶性"></a>判断一个数的奇偶性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="number">10</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">System.out.println((<span class="number">9</span> &amp; <span class="number">1</span>) == <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="不用临时变量交换两个数（面试常考）"><a href="#不用临时变量交换两个数（面试常考）" class="headerlink" title="不用临时变量交换两个数（面试常考）"></a>不用临时变量交换两个数（面试常考）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure><h3 id="取绝对值（某些机器上，效率比n-gt-0-n-n-高）"><a href="#取绝对值（某些机器上，效率比n-gt-0-n-n-高）" class="headerlink" title="取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）"></a>取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">System.out.println((n ^ (n &gt;&gt; <span class="number">31</span>)) - (n &gt;&gt; <span class="number">31</span>));</span><br><span class="line"><span class="comment">/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1</span></span><br><span class="line"><span class="comment">若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，</span></span><br><span class="line"><span class="comment">结果n变号并且绝对值减1，再减去-1就是绝对值 */</span></span><br></pre></td></tr></table></figure><h3 id="取两个数的最大值（某些机器上，效率比a-gt-b-a-b高）"><a href="#取两个数的最大值（某些机器上，效率比a-gt-b-a-b高）" class="headerlink" title="取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）"></a>取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）</h3><p><code>System.out.println(b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31));</code></p><h3 id="取两个数的最小值（某些机器上，效率比a-gt-b-b-a高）"><a href="#取两个数的最小值（某些机器上，效率比a-gt-b-b-a高）" class="headerlink" title="取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）"></a>取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）</h3><p><code>System.out.println(a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31));</code></p><h3 id="判断符号是否相同-true-表示-x和y有相同的符号，-false表示x，y有相反的符号。"><a href="#判断符号是否相同-true-表示-x和y有相同的符号，-false表示x，y有相反的符号。" class="headerlink" title="判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)"></a>判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)</h3><p><code>System.out.println((a ^ b) &gt; 0);</code></p><h3 id="计算2的n次方-n-gt-0"><a href="#计算2的n次方-n-gt-0" class="headerlink" title="计算2的n次方 n &gt; 0"></a>计算2的n次方 n &gt; 0</h3><p><code>System.out.println(2&lt;&lt;(n-1));</code></p><h3 id="判断一个数n是不是2的幂"><a href="#判断一个数n是不是2的幂" class="headerlink" title="判断一个数n是不是2的幂"></a>判断一个数n是不是2的幂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line">System.out.println((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果是2的幂，n一定是100... n-1就是1111....</span></span><br><span class="line"><span class="comment">所以做与运算结果为0*/</span></span><br></pre></td></tr></table></figure><h3 id="求两个整数的平均值"><a href="#求两个整数的平均值" class="headerlink" title="求两个整数的平均值"></a>求两个整数的平均值</h3><p><code>System.out.println((a+b) &gt;&gt; 1);</code></p><h3 id="从低位到高位-取n的第m位"><a href="#从低位到高位-取n的第m位" class="headerlink" title="从低位到高位,取n的第m位"></a>从低位到高位,取n的第m位</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">2</span>;</span><br><span class="line">System.out.println((n &gt;&gt; (m-<span class="number">1</span>)) &amp; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="从低位到高位-将n的第m位置为1"><a href="#从低位到高位-将n的第m位置为1" class="headerlink" title="从低位到高位.将n的第m位置为1"></a>从低位到高位.将n的第m位置为1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(n | (<span class="number">1</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/*将1左移m-1位找到第m位，得到000...1...000</span></span><br><span class="line"><span class="comment">n在和这个数做或运算*/</span></span><br></pre></td></tr></table></figure><h3 id="从低位到高位-将n的第m位置为0"><a href="#从低位到高位-将n的第m位置为0" class="headerlink" title="从低位到高位,将n的第m位置为0"></a>从低位到高位,将n的第m位置为0</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(n &amp; ~(<span class="number">0</span>&lt;&lt;(m-<span class="number">1</span>)));</span><br><span class="line"><span class="comment">/* 将1左移m-1位找到第m位，取反后变成111...0...1111</span></span><br><span class="line"><span class="comment">n再和这个数做与运算*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;位操作的概念与应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://crowzf.com/posts/28239a8d/"/>
    <id>https://crowzf.com/posts/28239a8d/</id>
    <published>2018-04-12T02:26:33.000Z</published>
    <updated>2018-04-17T06:01:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象的特征</p><a id="more"></a><h2 id="抽象-Abstract"><a href="#抽象-Abstract" class="headerlink" title="抽象 Abstract"></a>抽象 Abstract</h2><p>将一类对象的共同特征总结出来构造类的过程。</p><hr><p>##继承</p><p>子类从父类处继承信息</p><p>继承性是子类共享其父类数据和方法的机制。它由类的派生功能体现。一个类直接继承其他类的全部描述，同时可修改和扩充。继承具有传递性。继承分为单继承（一个子类有一父类）和多重继承（一个类有多个父类）。类的对象是各自封闭的，如果没继承性机制，则类的对象中的数据、方法就会出现大量重复。继承不仅支持系统的可重用性，而且还促进系统的可扩充性。</p><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>隐藏具体操作，只提供简单的编程接口和返回数据</p><p>封装是一种信息隐蔽技术，它体现于类的说明，是对象的重要特性。封装使数据和加工该数据的方法（函数）封装为一个整体，以实现独立性很强的模块，使得用户只能见到对象的外特性（对象能接受哪些消息，具有哪些处理能力），而对象的内特性（保存内部状态的私有数据和实现加工能力的算法）对用户是隐蔽的。封装的目的在于把对象的设计者和对象的使用者分开，使用者不必知晓其行为实现的细节，只须用设计者提供的消息来访问该对象。</p><p><strong>Getter 返回实例变量的值</strong><br><strong>Setter 设定实例变量的值</strong></p><p>为了避免数据泄露，导致变量的值可以通过点运算符来存取，应该使用 Setter 来给实例设置变量。强迫所有变量都必须调用 Setter 才能获取值。</p><p>实例变量应设置为 private<br>Setter 和 Getter 设置为 public</p><hr><h2 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h2><p>子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征。这意味着同一个类型的对象在执行同一方法时，可能表现出多种行为特征<br>建立一个装父类的数组，可以放入不同的子类对象，每个子类对象对父类的同一方法可作出不同响应<br>将父类作为方法的参数类型，或返回值类型，或数组类型，来避免为每一个子类创建新的方法<br>多态意味着多种形态。一个对象既是所属类的实例，也是 Object 类的实例</p><p>对象根据所接收的消息而做出动作。同一消息被不同的对象接受时可产生完全不同的行动，这种现象称为多态性。利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消息的对象自行决定，如是，同一消息即可调用不同的方法。例如：同样是 run 方法，飞鸟调用时是飞，野兽调用时是奔跑。多态性的实现受到继承性的支持，利用类继承的层次关系，把具有通用功能的协议存放在类层次中尽可能高的地方，而将实现这一功能的不同方法置于较低层次，这样，在这些低层次上生成的对象就能给通用消息以不同的响应。在 OOPL 中可通过在派生类中重定义基类函数（定义为重载函数或虚函数）来实现多态性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象的特征&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://crowzf.com/posts/79666db/"/>
    <id>https://crowzf.com/posts/79666db/</id>
    <published>2018-04-12T02:26:19.000Z</published>
    <updated>2018-04-17T06:00:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>链表、数组、枚举及数组列表</p><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>LinkedList继承自AbstractSequenceList，实现了 List、Deque、Cloneable、java.io.Serializable接口。AbstractSequenceList 提供了 List 接口骨干性的实现以减少实现 List 接口的复杂度，Deque 接口定义了双端队列的操作。<br>单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node 。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。 </p><p>上图中最左边的节点即为头节点（Head），（头节点也可以包含数据）。新增节点出现在头节点右侧，紧挨头节点。<br>引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。<br>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。 </p><p>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。单项链表的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 定义头节点</span></span><br><span class="line">LinkList&lt;T&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义节点类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h3><h4 id="查找单链表的中间节点"><a href="#查找单链表的中间节点" class="headerlink" title="查找单链表的中间节点"></a>查找单链表的中间节点</h4><p>采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找单链表的中间节点</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">SearchMid</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node p = <span class="keyword">this</span>.head, q = <span class="keyword">this</span>.head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.next != <span class="keyword">null</span> &amp;&amp; p.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">p = p.next.next;</span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"Mid:"</span> + q.data);</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="查找倒数第k个元素"><a href="#查找倒数第k个元素" class="headerlink" title="查找倒数第k个元素"></a>查找倒数第k个元素</h4><p>采用两个指针P1,P2，P1先前移K步，然后P1、P2同时移动，当p1移动到尾部时，P2所指位置的元素即倒数第k个元素 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查找倒数 第k个元素</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findElem</span><span class="params">(Node head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; <span class="keyword">this</span>.length()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node p1 = head;</span><br><span class="line">Node p2 = head;</span><br><span class="line"><span class="comment">// 前移k步</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">p1 = p1.next;</span><br><span class="line"><span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">p1 = p1.next;</span><br><span class="line">p2 = p2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h4 id="对链表进行排序"><a href="#对链表进行排序" class="headerlink" title="对链表进行排序"></a>对链表进行排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 排序</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">orderList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node nextNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">Node curNode = head;</span><br><span class="line"><span class="keyword">while</span> (curNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">nextNode = curNode.next;</span><br><span class="line"><span class="keyword">while</span> (nextNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (curNode.data &gt; nextNode.data) &#123;</span><br><span class="line">tmp = curNode.data;</span><br><span class="line">curNode.data = nextNode.data;</span><br><span class="line">nextNode.data = tmp;</span><br><span class="line">&#125;</span><br><span class="line">nextNode = nextNode.next;</span><br><span class="line">&#125;</span><br><span class="line">curNode = curNode.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a>删除链表中的重复节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除重复节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDuplecate</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node p = head;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">Node q = p;</span><br><span class="line"><span class="keyword">while</span> (q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.data == q.next.data) &#123;</span><br><span class="line">q.next = q.next.next;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">q = q.next;</span><br><span class="line">&#125;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="从尾到头输出单链表，采用递归方式实现"><a href="#从尾到头输出单链表，采用递归方式实现" class="headerlink" title="从尾到头输出单链表，采用递归方式实现"></a>从尾到头输出单链表，采用递归方式实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从尾到头输出单链表，采用递归方式实现</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pListHead</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printListReversely</span><span class="params">(Node pListHead)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pListHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">printListReversely(pListHead.next);</span><br><span class="line">System.out.println(<span class="string">"printListReversely:"</span> + pListHead.data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="判断链表是否有环，有环情况下找出环的入口节点"><a href="#判断链表是否有环，有环情况下找出环的入口节点" class="headerlink" title="判断链表是否有环，有环情况下找出环的入口节点"></a>判断链表是否有环，有环情况下找出环的入口节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断链表是否有环，单向链表有环时，尾节点相同</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsLoop</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node fast = head, slow = head;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">System.out.println(<span class="string">"该链表有环"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> !(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 找出链表环的入口</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">FindLoopPort</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">Node fast = head, slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line"><span class="keyword">if</span> (slow == fast)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">slow = head;</span><br><span class="line"><span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="添加节点的方法很明显违反了单链表先进后出的原则"><a href="#添加节点的方法很明显违反了单链表先进后出的原则" class="headerlink" title="添加节点的方法很明显违反了单链表先进后出的原则"></a>添加节点的方法很明显违反了单链表先进后出的原则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(d);</span><br><span class="line">newNode.next = head;</span><br><span class="line">head = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。</p><p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreshJuice</span> </span>&#123;</span><br><span class="line">   <span class="keyword">enum</span> FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125;</span><br><span class="line">   FreshJuiceSize size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshJuiceTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">      FreshJuice juice = <span class="keyword">new</span> FreshJuice();</span><br><span class="line">      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>JAVA 数组是静态的，声明后长度不可改变，仅数值可改变</strong></p><p>数组初始化的两种方式</p><ul><li>静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。</li><li>动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。</li></ul><p>【初始化数组时，不要同时使用静态和动态方法】</p><p><strong>数组变量是引用变量</strong><br>数组变量不是数组本身，它指向堆内存中的数组对象。改变数组变量所引用的数组，可以造成数组长度可变的假象</p><p>多维数组<br>即数组套数组<br><code>int[][]</code></p><hr><h2 id="数组列表-ArrayList"><a href="#数组列表-ArrayList" class="headerlink" title="数组列表 ArrayList"></a>数组列表 ArrayList</h2><p>ArrayList 类扩展 AbstractList，并实现了 List 接口。支持 ArrayList 动态数组根据需要可以增长。</p><p>标准的 Java 数组是一个固定长度的。创建数组后，他们不能生长或缩小，这意味着必须事先知道数组将容纳多少元素。</p><p>数组列表是用初始大小创建。但添加元素时，会自动放大。删除元素时，会自动缩小。</p><p><code>ArrayList</code>是泛型类，应指定其内部所保存的元素类型。使用<code>&lt;类型&gt;</code>接在<code>ArrayList</code>后面</p><h3 id="构造函数。"><a href="#构造函数。" class="headerlink" title="构造函数。"></a>构造函数。</h3><ul><li><p><code>ArrayList&lt;E&gt;()</code><br>构造一个空数组列表</p></li><li><p><code>ArrayList&lt;E&gt;(int initalCapacity)</code></p></li><li><p>用指定容量构造一个空数组列表</p></li><li><p><code>ArrayList(Collection c)</code><br>建立一个与集合c 的元素初始化一个数组列表。</p></li></ul><p><strong>菱形语法</strong><br><code>ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;()</code><br>`ArrayList<employee> staff = new ArrayList&lt;&gt;(); </employee></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>除了从它的父类继承的方法，ArrayList中定义了以下方法：</p><ul><li><p><code>void add(int index, Object element)</code><br>插入指定位置的索引在此列表中的指定元素。如果指定的索引超出<code>range (index &lt; 0 || index &gt; size())</code>，抛出<code>IndexOutOfBoundsException</code>异常。</p></li><li><p><code>boolean add(Object o)</code><br>将指定的元素添加到ArrayList的末尾，永远返回<code>ture</code>。</p></li><li><p><code>void ensureCapacity(int Capacity)</code><br>确保ArrayList在不重新分配存储空间的情况下就能够保存给定数量的元素。</p></li><li><p><code>void trimToSize()</code><br>将ArrayList的存储容量削减到当前尺寸。</p></li><li><p><code>boolean addAll(Collection c)</code><br>所有追加指定<code>collection</code>中的元素添加到此列表的结尾，因为它们是由指定<code>collection</code>的迭代器返回的顺序。，如果指定集合为<code>null</code>，抛出<code>NullPointerException</code>异常。</p></li><li><p><code>boolean addAll(int index, Collection c)</code><br>插入所有指定集合中的元素插入此列表，开始在指定的位置。抛出NullPointerException异常，如果指定集合为null。</p></li><li><p><code>void clear()</code><br>移除此列表中的元素。</p></li><li><p><code>Object clone()</code><br>返回此ArrayList浅表副本。</p></li><li><p><code>boolean contains(Object o)</code><br>如果此列表包含指定的元素返回true。更正式地说，当且仅当此列表包含至少一个元素e，使得返回true (o==null ? e==null : o.equals(e)).</p></li><li><p><code>Object get(int index)</code><br>返回此列表中指定位置的元素。抛出IndexOutOfBoundsException异常，如果指定的索引超出range (index &lt; 0 || index &gt;= size()).</p></li><li><p><code>int indexOf(Object o)</code><br>返回索引中的指定元素第一次出现的这个名单，或者-1，如果列表中不包含该元素。</p></li><li><p><code>int lastIndexOf(Object o)</code><br>返回索引中的指定元素中最后出现的这个名单，或者-1，如果列表中不包含该元素。</p></li><li><p><code>Object remove(int index)</code><br>移除元素在此列表中的指定位置。如果索引超出 range (index &lt; 0 || index &gt;= size()) 抛出一个IndexOutOfBoundsException。</p></li><li><p><code>protected void removeRange(int fromIndex, int toIndex)</code><br>从这个列表中删除所有索引为fromIndex（包括）和toIndex，独占的元素。</p></li><li><p><code>Object set(int index, Object element)</code><br>替换元素在与指定元素在此列表中的指定位置。抛出IndexOutOfBoundsException异常，如果指定的索引超出 range (index &lt; 0 || index &gt;= size()).</p></li><li><p><code>int size()</code><br>返回此列表中的元素数。</p></li><li><p><code>Object[] toArray()</code><br>返回包含所有在此列表中正确的顺序元素的数组。抛出NullPointerException异常如果指定数组为null。</p></li><li><p><code>Object[] toArray(Object[] a)</code><br>返回包含所有在此列表中正确的顺序元素的数组;返回数组的运行时类型是指定数组。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表、数组、枚举及数组列表&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收器</title>
    <link href="https://crowzf.com/posts/fe8a6aab/"/>
    <id>https://crowzf.com/posts/fe8a6aab/</id>
    <published>2018-04-12T02:26:15.000Z</published>
    <updated>2018-04-17T05:59:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收的方法</p><a id="more"></a><p>失去引用的对象将被 GC 列入“可回收名单”，但不一定立即回收。</p><p>1.标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片</p><p>2.标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率</p><p>3.复制回收法：把现有内存空间分成两部分，GC 运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。</p><p>4.分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法</p><p>5.引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程</p><p>6.对象引用遍历（现在大多数 JVM 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收的方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>静态变量</title>
    <link href="https://crowzf.com/posts/179f63b0/"/>
    <id>https://crowzf.com/posts/179f63b0/</id>
    <published>2018-04-12T02:26:00.000Z</published>
    <updated>2018-04-17T06:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>静态变量与静态方法</p><a id="more"></a><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul><li><p>静态变量只有在第一次加载类的时候才会被初始化，而不是每次创建实例都初始化。因此对于该类的所有实例，值都相同。静态变量是所有实例共享的，相同的值。某个对象修改了静态变量的值后，其他对象访问改静态变量得到的是修改后的值。</p></li><li><p>实例变量：每个实例独占一个，1000个对象有1000个实例变量，属于对象。</p></li><li><p>静态变量：每个类只有一个，1000个对象共享同1个，属于类。即使没有对象，也存在着。</p></li><li><p>创建对象前，静态变量必须被初始化完毕。</p></li><li><p>调用类中的静态方法前，静态变量必须被初始化完毕。</p></li><li><p>通过类名（而非对象名）访问静态变量。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> playerCounst; <span class="comment">// int 类型默认值为0</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    playerCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerTestDrive</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            System.out.pintln(Player.playerCount);</span><br><span class="line">            Player one = <span class="keyword">new</span> Player(<span class="string">"Tiger Woods"</span>);</span><br><span class="line">            Systen.out.println(Player.playerCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>静态方法不能对实例进行操作，不能使用实例变量的值。因此调用静态方法时，不需要对象，直接使用类名。</li><li>​<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = Math.round(<span class="number">42.2</span>);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(<span class="number">56</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">int</span> z = Math.abs(-<span class="number">343</span>);</span><br></pre></td></tr></table></figure></li></ul><p>需要静态方法的场合：</p><ul><li>一个方法不需要访问对象状态，其所有参数都是通过显示参数提供（例如：Math.pow)。</li><li>一个方法只需要访问类的静态变量。</li><li><p>使用静态工厂方法来构造对象。</p></li><li><p>静态方法可以在堆内存中没有类的实例的情况下调用。</p></li><li>静态方法可以访问静态变量。</li><li><p>但使用引用变量调用静态方法是允许的，这会造成混淆。不推荐。</p></li><li><p>拥有静态方法的类不应该被初始化，这可以通过把构造器声明为 Private 来实现。但不意味着无法被初始化，例如拥有 main 方法的类。</p></li><li><p>静态方法不能调用非静态方法，因为非静态方法通常会有实例变量。即使方法中没有使用实例变量也不可以。避免日后会修改该方法导致使用实例变量，或子类重写该方法导致使用实例变量。</p></li></ul><hr><h2 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h2><p>不通过<code>new</code>，而是用一个静态方法来对外提供自身实例的方法。</p><p>Fragment </p><p>静态工厂方法的优势</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态变量与静态方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>接口Interface</title>
    <link href="https://crowzf.com/posts/990f7b7d/"/>
    <id>https://crowzf.com/posts/990f7b7d/</id>
    <published>2018-04-12T02:25:45.000Z</published>
    <updated>2018-04-17T05:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 接口并对比抽象类</p><a id="more"></a><p>接口（Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 <code>interface</code> 来声明。一个类通过实现接口的方式，从而实现接口的抽象方法</p><ul><li>用于强调某个类应实现的功能。</li><li>接口并不是类，无法被实例化。</li><li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li><li>接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</li></ul><hr><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>一个类只能继承一个抽象类。但可以实现多个接口。</p><h2 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h2><ul><li>一个接口可以有多个方法</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名</li><li>接口的字节码文件保存在 .class 结尾的文件中</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中</li></ul><hr><h2 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h2><ul><li>接口不能用于实例化对象</li><li>接口没有构造方法</li><li>接口中所有的方法必须是抽象方法</li><li>接口不能包含成员变量，除了 <code>static</code> 和 <code>final</code> 变量</li><li>接口不是被类继承了，而是要被类实现</li><li>接口支持多继承</li></ul><hr><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <code>public abstract</code>（只能是 <code>public abstract</code>，其他修饰符都会报错）</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <code>public static final</code> 变量（并且只能是 <code>public</code>，用 <code>private</code> 修饰会报编译错误）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法</li></ul><hr><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul><li>接口强调要实现的功能，抽象类强调继承（所属）关系。</li><li>抽象类中的方法可以有方法体（非抽象方法），但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <code>public static final</code> 类型的。</li><li>接口中不能含有静态代码块以及静态方法，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><hr><h2 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h2><p>接口的声明语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;可见度&gt; <span class="class"><span class="keyword">interface</span> 接口名称 <span class="keyword">extends</span> &lt;其他的类名&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 声明变量</span></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名 : NameOfInterface.java</span></span><br><span class="line"><span class="comment">// 引入包</span></span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NameOfInterface</span></span>&#123;</span><br><span class="line"><span class="comment">//任何类型 final, static 字段</span></span><br><span class="line"><span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。<br>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>实现一个接口的语法，可以使用这个公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : MammalInt.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Mammal eats"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Mammal travels"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">m.eat();</span><br><span class="line">m.travel();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li><li>​</li></ul><hr><p>在实现接口的时候，也要注意一些规则：</p><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><hr><h2 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h2><p>一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用<code>extends</code>关键字，子接口继承父接口的方法。<br>下面的Sports接口被Hockey和Football接口继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件名: Sports.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHomeTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisitingTeam</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名: Football.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingTeamScored</span><span class="params">(<span class="keyword">int</span> points)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfQuarter</span><span class="params">(<span class="keyword">int</span> quarter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名: Hockey.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">homeGoalScored</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitingGoalScored</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endOfPeriod</span><span class="params">(<span class="keyword">int</span> period)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overtimePeriod</span><span class="params">(<span class="keyword">int</span> ot)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hockey 接口自己声明了四个方法，从 Sports 接口继承了两个方法，这样，实现 Hockey 接口的类需要实现六个方法。</p><p>相似的，实现Football接口的类需要实现五个方法，其中两个来自于 Sports 接口。</p><hr><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>在 Java 中，类的多继承是不合法，但接口允许多继承。<br>在接口的多继承中<code>extends</code>关键字只需要使用一次，在其后跟着继承接口。如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hockey</span> <span class="keyword">extends</span> <span class="title">Sports</span>, <span class="title">Event</span></span></span><br></pre></td></tr></table></figure><p>以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法</p><hr><h2 id="标识接口"><a href="#标识接口" class="headerlink" title="标识接口"></a>标识接口</h2><p>最常用的继承接口是没有包含任何方法的接口，它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。<br>标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。<br>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：<br>建立一个公共的父接口：<br>正如 EventListener 接口，这是由几十个其他接口扩展的 Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener 接口，Java 虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p><p>向一个类添加数据类型：<br>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 接口并对比抽象类&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基本类型Primitive_type</title>
    <link href="https://crowzf.com/posts/4d6a6177/"/>
    <id>https://crowzf.com/posts/4d6a6177/</id>
    <published>2018-04-12T02:25:35.000Z</published>
    <updated>2018-04-17T05:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 的8种基本类型</p><a id="more"></a><h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><ul><li><code>byte</code>数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 -128（-2^7）；</li><li>最大值是 127（2^7-1）；</li><li>默认值是 0；</li><li><code>byte</code>类型用在大型数组中节约空间，主要代替整数，因为<code>byte</code>变量占用的空间只有<code>int</code>类型的四分之一；<blockquote><p>例子：<code>byte a = 10; byte b = -50</code></p></blockquote></li></ul><hr><h2 id="short"><a href="#short" class="headerlink" title="short"></a>short</h2><ul><li>short 数据类型是 16位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li><code>short</code>数据类型也可以像<code>byte</code> 那样节省空间。一个<code>short</code>变量是<code>int</code>型变量所占空间的二分之一；</li><li>默认值是 0；<blockquote><p>例子：<code>short s = 1000; short r = -20000</code></p></blockquote></li></ul><hr><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><ul><li><code>int</code>数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>通常，整型变量默认为 <code>int</code> 类型；</li><li>默认值是 0 ；<blockquote><p>例子：<code>int a = 100000; int b = -200000</code></p></blockquote></li></ul><hr><h2 id="long"><a href="#long" class="headerlink" title="long"></a>long</h2><ul><li><code>long</code> 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 0L；<blockquote><p>例子： long a = 100000L，Long b = -200000L。</p></blockquote></li></ul><p><em>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</em></p><hr><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><ul><li><code>float</code> 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li><code>float</code> 在储存大型浮点数组的时候可节省内存空间；</li><li>应加上 f 或 F</li><li>默认值是 0.0f；</li><li>浮点数不能用来表示精确的值，如货币；<blockquote><p>例子：float f1 = 234.5f。</p></blockquote></li></ul><hr><h2 id="double"><a href="#double" class="headerlink" title="double"></a>double</h2><ul><li><code>double</code> 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为<code>double</code>类型；</li><li><code>double</code> 类型同样不能表示精确的值，如货币；</li><li>默认值是 0.0d；<blockquote><p>例子：double d1 = 123.4。</p></blockquote></li></ul><hr><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><ul><li><code>boolean</code>数据类型表示一位的信息；</li><li>只有两个取值：<code>true</code> 和 <code>false</code>；</li><li>这种类型只作为一种标志来记录 <code>true/false</code> 情况；</li><li>默认值是 <code>false</code>；<blockquote><p>例子：boolean one = true。</p></blockquote></li></ul><hr><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><ul><li><code>char</code>类型是一个单一的 16 位 Unicode 字符；</li><li>用单引号赋值</li><li>最小值是 \u0000（即为0）；</li><li>最大值是 \uffff（即为65,535）；</li><li>char 数据类型可以储存任何字符；<blockquote><p>例子：char letter = ‘A’;。</p></blockquote></li></ul><ul><li>有些 Unicode 字符可以用一个 <code>char</code> 值描述，另外一些 Unicode 字符则需要两个 char 值</li><li>16位的 <code>char</code> 类型最多只能描述 65536 个代码值，现在已经不够了</li><li><strong>码点</strong> (code point)是编码表中某个字符对应的代码值，采用十六进制书写，前缀 U+。如 A 的码点是 U+0041<ul><li>码点分为17个 <strong>代码级别</strong> (code plane)。第一个代码级别是 <strong>基本的多语言级别</strong> (basic multilingual plane)。码点从 U+0000 到 U+FFFF ，包括经典的 Unicode 代码。其余16个代码级别从 U+10000 到 U+10FFFF，包括一些 <strong>辅助字符</strong> (supplementary character)。</li></ul></li><li>基本的多语言级别中，每个字符用16位表示，称为 <strong>代码单元(code unit)</strong> ，辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内，被称为 <em>替代区域(surrogate area)</em> 。【U+D800 ~ U+DBFF用于第一个代码单元(共1024字节），U+DC00 ~ U+DFFF（共1024字节）用于第二个代码单元】。这样可以知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 的8种基本类型&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关键字</title>
    <link href="https://crowzf.com/posts/fe7c7d2d/"/>
    <id>https://crowzf.com/posts/fe7c7d2d/</id>
    <published>2018-04-12T02:25:25.000Z</published>
    <updated>2018-04-17T05:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 关键字列表</p><a id="more"></a><p>下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">关键字</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">访问控制</td><td style="text-align:center">private</td><td style="text-align:center">私有的</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">protected</td><td style="text-align:center">受保护的</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">public</td><td style="text-align:center">公共的</td></tr><tr><td style="text-align:center">类、方法和变量修饰符</td><td style="text-align:center">abstract</td><td style="text-align:center">声明抽象</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">class</td><td style="text-align:center">类</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">extends</td><td style="text-align:center">扩允,继承</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">final</td><td style="text-align:center">最终值,不可改变的</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">implements</td><td style="text-align:center">实现（接口）</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">interface</td><td style="text-align:center">接口</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">native</td><td style="text-align:center">本地，原生方法（非Java实现）</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">new</td><td style="text-align:center">新,创建</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">static</td><td style="text-align:center">静态</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">strictfp</td><td style="text-align:center">严格,精准</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">synchronized</td><td style="text-align:center">线程,同步</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">transient</td><td style="text-align:center">短暂</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">volatile</td><td style="text-align:center">易失</td></tr><tr><td style="text-align:center">程序控制语句</td><td style="text-align:center">break</td><td style="text-align:center">跳出循环</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">case</td><td style="text-align:center">定义一个值以供switch选择</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">continue</td><td style="text-align:center">继续</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">default</td><td style="text-align:center">默认</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">do</td><td style="text-align:center">运行</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">else</td><td style="text-align:center">否则</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">for</td><td style="text-align:center">循环</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">if</td><td style="text-align:center">如果</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">instanceof</td><td style="text-align:center">实例</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">return</td><td style="text-align:center">返回</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">switch</td><td style="text-align:center">根据值选择执行</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">while</td><td style="text-align:center">循环</td></tr><tr><td style="text-align:center">错误处理</td><td style="text-align:center">assert</td><td style="text-align:center">断言表达式是否为真</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">catch</td><td style="text-align:center">捕捉异常</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">finally</td><td style="text-align:center">有没有异常都执行</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">throw</td><td style="text-align:center">抛出一个异常对象</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">throws</td><td style="text-align:center">声明一个异常可能被抛出</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">try</td><td style="text-align:center">捕获异常</td></tr><tr><td style="text-align:center">包相关</td><td style="text-align:center">import</td><td style="text-align:center">引入</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">package</td><td style="text-align:center">包</td></tr><tr><td style="text-align:center">基本类型</td><td style="text-align:center">boolean</td><td style="text-align:center">布尔型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">byte</td><td style="text-align:center">字节型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">char</td><td style="text-align:center">字符型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">double</td><td style="text-align:center">双精度浮点</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">float</td><td style="text-align:center">单精度浮点</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">int</td><td style="text-align:center">整型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">long</td><td style="text-align:center">长整型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">short</td><td style="text-align:center">短整型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">null</td><td style="text-align:center">空</td></tr><tr><td style="text-align:center">变量引用</td><td style="text-align:center">super</td><td style="text-align:center">父类,超类</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">this</td><td style="text-align:center">本类</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">void</td><td style="text-align:center">无返回值</td></tr><tr><td style="text-align:center">保留关键字</td><td style="text-align:center">goto</td><td style="text-align:center">是关键字，但不能使用</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">const</td><td style="text-align:center">是关键字，但不能使用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 关键字列表&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>构造过程</title>
    <link href="https://crowzf.com/posts/92e0508e/"/>
    <id>https://crowzf.com/posts/92e0508e/</id>
    <published>2018-04-12T02:25:21.000Z</published>
    <updated>2018-04-17T06:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>从内存角度理解对象构造过程</p><a id="more"></a><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><code>Dog myDog = new Dog();</code></p><ol><li><em>声明一个引用变量</em> ：要求 Java 虚拟机分配空间给一个引用变量 ，这个引用变量是 Dog 类型，叫做 myDog。存储在变量所属的方法栈中。</li><li><em>创建对象</em> ：要求 Java 虚拟机分配 <em>堆空间</em> 给新建立的 Dog <em>对象</em>。这里的 new 语法是在调用类的构造器，如果构造器中有代码，可以运行。</li><li>连接对象和引用： 将<em>获取 Dog 对象的方法</em>以字节形式放进引用变量中。<br>换言之，引用变量(遥控器)是获得对象的某种神秘方法，而不是变量本身。</li></ol><p>同一个 Java 虚拟机的引用变量是固定大小。</p><hr><h2 id="对象的初始化过程"><a href="#对象的初始化过程" class="headerlink" title="对象的初始化过程"></a>对象的初始化过程</h2><ol><li>调用<code>Object</code>类的非静态初始化块</li><li>调用<code>Object</code>类的构造器</li><li>调用父类的非静态初始化块</li><li>调用父类的构造器</li><li>调用非静态初始化块</li><li>调用构造器</li><li>（如果有super()）根据实参列表决定调用哪个父类构造器</li><li>（如果有this()）调用同类中指定的构造器</li></ol><hr><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>对象要先运行构造器，才能赋值给一个引用。</li><li>构造器必须与类同名。</li><li>构造器没有返回值。而函数方法必须有返回值。</li><li>一个类可以有多个构造器：重载构造器</li><li>默认构造器<br><code>public Duck(){}</code></li><li>自定构造器<br><code>public Duck(int duckSize) {}</code></li><li>构造器中的代码可以让对象在被创建时进行一些自定义。如打印信息等。</li><li>对于一个在不同对象中，值会发生变化的实例变量，考虑在构造器中为实例变量赋值，一来可以避免创建对象后还要调用 <code>setter</code> 方法赋值。二来可以使实例变量从出生就有值，避免出现赋值前的“真空期”（未赋值时由系统指定默认值）。</li><li>如果对象必须等待其内部某个实例变量被赋值后才能使用，期待创建对象的人调用 <code>setter</code> 方法来赋值是不靠谱的。应该将这样的变量作为参数传入类的构造器。使得用户在创建实例时，必须传入参数的值才能构造。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">// 假设该参数必须赋值</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造器（无参构造器）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 默认值</span></span><br><span class="line">size = <span class="number">27</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(<span class="keyword">int</span> duckSize)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过参数赋值</span></span><br><span class="line">size = duckSize;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有当类缺少自定构造器时，编译器才会自动给与默认构造器。换言之，如果有自定构造器，还必须自行编写一个默认构造器。</li><li>创建实例时，对象的继承树上的所有构造器都必须运行。对象的构造器会沿继承树向上调用所有父类的构造器，直到 <code>Object</code> 类的构造器。编译器隐式地使用 <code>super()</code>。</li><li>如果你没有给类提供构造器，编译器会自动提供一个 <code>super()</code>。如果你提供了构造器，编译器会在每个构造器的第一行加入 <code>super()</code>。</li><li>抽象类型也拥有构造器，即使不能创建抽象类型的实例，但创建其子类的实例时还是要运行父类的构造器。因为子类中可能会用到父类中定义的变量的值。</li><li>使用 super() 来调用父类的构造器，<code>super()</code>必须放在构造器的第一行。</li><li>在构造器中调用其他构造器并传入参数：使用 <code>this(arg)</code> 方法。 <code>this(args)</code> 方法只能用在构造器中，且必须是构造器的第一行语句。</li><li>构造器中，<code>super()</code> 和 <code>this()</code> 只能选用其一。</li></ul><hr><h2 id="极端情况下的父类访问子类的实例变量的方法"><a href="#极端情况下的父类访问子类的实例变量的方法" class="headerlink" title="极端情况下的父类访问子类的实例变量的方法"></a>极端情况下的父类访问子类的实例变量的方法</h2><p><code>this</code> 处于构造器中时，代表的是正在初始化的 Java 对象。</p><blockquote><p>子类构造器调用父类构造器，父类构造器中有 <code>this</code>，这个 <code>this</code> 代表的是子类，因为当时父类构造器中的代码是放在子类构造器中执行的。</p></blockquote><p>当变量的编译时类型和运行时类型不同时</p><ul><li>​</li></ul><hr><h2 id="特殊情况下父类调用被子类重写的方法"><a href="#特殊情况下父类调用被子类重写的方法" class="headerlink" title="特殊情况下父类调用被子类重写的方法"></a>特殊情况下父类调用被子类重写的方法</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从内存角度理解对象构造过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>格式指定</title>
    <link href="https://crowzf.com/posts/7d9efe37/"/>
    <id>https://crowzf.com/posts/7d9efe37/</id>
    <published>2018-04-12T02:25:15.000Z</published>
    <updated>2018-04-17T06:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>格式化字符串</p><a id="more"></a><hr><p><em>格式化字符串</em></p><ul><li>%d：decimal 兼容int, byte, short, char</li><li>%f：floating point number 兼容float 和 double</li><li>%x：hexadecimal 十六进制</li><li>%c：character 字符</li><li>%tc：完整时间（星期 月 日 时间 MST时区？ß 年）</li><li>%tr：时间</li><li>%ta：星期几</li><li>%tB：月份</li><li>%td：几号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date today = <span class="keyword">new</span> Date();</span><br><span class="line">String.format(“%A, %&lt;tB, %td<span class="string">", today);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;格式化字符串&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分支语句</title>
    <link href="https://crowzf.com/posts/dc306f3e/"/>
    <id>https://crowzf.com/posts/dc306f3e/</id>
    <published>2018-04-12T02:25:01.000Z</published>
    <updated>2018-04-17T05:59:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>break, continue 与 return</p><a id="more"></a><h2 id="The-break-Statement"><a href="#The-break-Statement" class="headerlink" title="The break Statement"></a>The break Statement</h2><p>The break statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the switch statement. You can also use an unlabeled break to terminate a for, while, or do-while loop, as shown in the following BreakDemo program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arrayOfInts = </span><br><span class="line">            &#123; <span class="number">32</span>, <span class="number">87</span>, <span class="number">3</span>, <span class="number">589</span>,</span><br><span class="line">              <span class="number">12</span>, <span class="number">1076</span>, <span class="number">2000</span>,</span><br><span class="line">              <span class="number">8</span>, <span class="number">622</span>, <span class="number">127</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> searchfor = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">boolean</span> foundIt = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayOfInts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrayOfInts[i] == searchfor) &#123;</span><br><span class="line">                foundIt = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundIt) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Found "</span> + searchfor + <span class="string">" at index "</span> + i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(searchfor + <span class="string">" not in the array"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This program searches for the number 12 in an array. The break statement, shown in boldface, terminates the for loop when that value is found. Control flow then transfers to the statement after the for loop. This program’s output is:</p><blockquote><p>Found 12 at index 4</p></blockquote><p>An unlabeled break statement terminates the innermost switch, for, while, or do-while statement, but a labeled break terminates an outer statement. The following program, BreakWithLabelDemo, is similar to the previous program, but uses nested for loops to search for a value in a two-dimensional array. When the value is found, a labeled break terminates the outer for loop (labeled “search”):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreakWithLabelDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] arrayOfInts = &#123; </span><br><span class="line">            &#123; <span class="number">32</span>, <span class="number">87</span>, <span class="number">3</span>, <span class="number">589</span> &#125;,</span><br><span class="line">            &#123; <span class="number">12</span>, <span class="number">1076</span>, <span class="number">2000</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">622</span>, <span class="number">127</span>, <span class="number">77</span>, <span class="number">955</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> searchfor = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> foundIt = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    search:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayOfInts.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; arrayOfInts[i].length;</span><br><span class="line">                 j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arrayOfInts[i][j] == searchfor) &#123;</span><br><span class="line">                    foundIt = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span> search;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundIt) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Found "</span> + searchfor + <span class="string">" at "</span> + i + <span class="string">", "</span> + j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(searchfor + <span class="string">" not in the array"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is the output of the program.</p><blockquote><p>Found 12 at 1, 0</p></blockquote><p>The break statement terminates the labeled statement; it does not transfer the flow of control to the label. Control flow is transferred to the statement immediately following the labeled (terminated) statement.</p><h2 id="The-continue-Statement"><a href="#The-continue-Statement" class="headerlink" title="The continue Statement"></a>The continue Statement</h2><p>The continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop’s body and evaluates the boolean expression that controls the loop. The following program, ContinueDemo , steps through a String, counting the occurences of the letter “p”. If the current character is not a p, the continue statement skips the rest of the loop and proceeds to the next character. If it is a “p”, the program increments the letter count.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContinueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String searchMe = <span class="string">"peter piper picked a "</span> + <span class="string">"peck of pickled peppers"</span>;</span><br><span class="line">        <span class="keyword">int</span> max = searchMe.length();</span><br><span class="line">        <span class="keyword">int</span> numPs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// interested only in p's</span></span><br><span class="line">            <span class="keyword">if</span> (searchMe.charAt(i) != <span class="string">'p'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// process p's</span></span><br><span class="line">            numPs++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Found "</span> + numPs + <span class="string">" p's in the string."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is the output of this program:</p><blockquote><p>Found 9 p’s in the string.</p></blockquote><p>To see this effect more clearly, try removing the continue statement and recompiling. When you run the program again, the count will be wrong, saying that it found 35 p’s instead of 9.<br>A labeled continue statement skips the current iteration of an outer loop marked with the given label. The following example program, ContinueWithLabelDemo, uses nested loops to search for a substring within another string. Two nested loops are required: one to iterate over the substring and one to iterate over the string being searched. The following program, ContinueWithLabelDemo, uses the labeled form of continue to skip an iteration in the outer loop.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContinueWithLabelDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String searchMe = <span class="string">"Look for a substring in me"</span>;</span><br><span class="line">        String substring = <span class="string">"sub"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> foundIt = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = searchMe.length() - </span><br><span class="line">                  substring.length();</span><br><span class="line"></span><br><span class="line">    test:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = substring.length();</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (searchMe.charAt(j++) != substring.charAt(k++)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> test;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            foundIt = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span> test;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(foundIt ? <span class="string">"Found it"</span> : <span class="string">"Didn't find it"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is the output from this program.</p><blockquote><p>Found it</p></blockquote><h2 id="The-return-Statement"><a href="#The-return-Statement" class="headerlink" title="The return Statement"></a>The return Statement</h2><p>The last of the branching statements is the return statement. <em>The return statement exits from the current method, and control flow returns to where the method was invoked.</em> The return statement has two forms: one that returns a value, and one that doesn’t. To return a value, simply put the value (or an expression that calculates the value) after the return keyword.</p><p><code>return ++count;</code></p><p>The data type of the returned value must match the type of the method’s declared return value. When a method is declared void, use the form of return that doesn’t return a value.</p><p><code>return;</code></p><p>The Classes and Objects lesson will cover everything you need to know about writing methods.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;break, continue 与 return&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对象的强、软、弱、虚引用</title>
    <link href="https://crowzf.com/posts/8a9fd61b/"/>
    <id>https://crowzf.com/posts/8a9fd61b/</id>
    <published>2018-04-12T02:23:16.000Z</published>
    <updated>2018-04-17T05:59:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 JDK 1.2 以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从 JDK 1.2 版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p><a id="more"></a><h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><ul><li><code>Object obj = new Object();</code></li><li>如果一个对象具有强引用，则 GC(Garbage Collection) 时绝不会回收它。</li><li>当内存空间不足，JVM 宁愿抛出 OutOfMemoryError 错误，使程序异常终止。</li></ul><hr><h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><ul><li><code>java.lang.ref.SoftReference</code></li><li>用于描述还有用，但并非必须的对象。</li><li>当堆将发生 OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出 OOM。</li><li>软引用可用来实现内存敏感的高速缓存。(见后例）</li><li>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被 GC，JVM 就会把这个软引用加入到与之关联的引用队列中。</li></ul><p>示例：实现学生信息查询操作时有两套数据操作的方案（如后退操作，查询上一个刚刚查询过的信息）</p><ol><li>将得到的信息存放在内存中，后续查询则直接读取内存信息。</li></ol><ul><li>优点：读取速度快；</li><li>缺点：内存空间一直被占，若资源访问量不高，则浪费内存空间</li></ul><ol start="2"><li>每次查询均从数据库读取，然后填充到 TO 返回。</li></ol><ul><li>优点：内存空间将被 GC 回收，不会一直被占用。</li><li>缺点：在 GC 发生之前已有的 TO 依然存在，但还是执行了一次数据库查询，浪费IO</li></ul><p><em>通过软引用解决</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 获取数据并缓存</span></span><br><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference softRef = <span class="keyword">new</span> SoftReference(object, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次使用时</span></span><br><span class="line">Object object = (Object)softRef.get();</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// 当软引用被回收后才重新获取</span></span><br><span class="line">  object = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理被收回后剩下来的软引用对象</span></span><br><span class="line">SoftReference ref = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((ref = queue.poll()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">// 清理工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><ul><li><code>java.lang.ref.WeakReference</code></li><li>GC 时必定收回弱引用指向的内存空间</li><li>不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</li><li>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被 GC，JVM就会把这个弱引用加入到与之关联的引用队列中。 </li></ul><hr><h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><ul><li><code>java.lang.ref.PhantomReference</code></li><li>虚引用不会决定对象的生命周期，也无法通过需引用来获取对象实例。仅用于在发生 GC 时接受一个系统通知。</li><li>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li><li>虚引用与软引用和弱引用的一个区别在于：<em>虚引用必须和引用队列 （ReferenceQueue）联合使用。</em>当 GC 准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li><li><code>ReferenceQueue queue = new ReferenceQueue();</code><br><code>PhantomReference pr = new PhantomReference(object, queue);</code></li></ul><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><hr><h2 id="引用队列-Reference-Queue"><a href="#引用队列-Reference-Queue" class="headerlink" title="引用队列(Reference Queue)"></a>引用队列(Reference Queue)</h2><ul><li><code>java.lang.ref.ReferenceQueue</code></li><li><p>引用队列配合 Reference 的子类等使用，当引用对象所指向的内存空间被 GC 回收后，该引用对象则被追加到引用队列的末尾（源码中 <code>boolean enqueue(Reference&lt;? extends T&gt; r) { /* Called only by Reference class */</code>说明只供Reference实例调用，且仅能调用一次）。引用队列有如下实例方法：</p></li><li><p><code>Reference&lt;? extends T&gt; ReferenceQueue#poll()</code><br>从队列中出队一个元素，若队列为空则返回null。</p></li><li><code>Reference&lt;? extends T&gt; ReferenceQueue#remove()</code><br>从队列中出队一个元素，若没有则阻塞直到有元素可出队。</li><li><code>Reference&lt;? extends T&gt; ReferenceQueue#remove(long timeout)</code><br>从队列中出队一个元素，若没有则阻塞直到有元素可出队或超过 timeout 指定的毫秒数（由于采用<code>wait(long timeout)</code>方式实现等待，因此时间不能保证）。</li></ul><hr><h2 id="判断可达性-可触及性-Reachable"><a href="#判断可达性-可触及性-Reachable" class="headerlink" title="判断可达性/可触及性(Reachable)"></a>判断可达性/可触及性(Reachable)</h2><ol><li>单条引用链的可达性以最弱的一个引用类型来决定；</li><li>多条引用链的可达性以最强的一个引用类型来决定；</li></ol><p>可达性分析用于判断对象是否存活。</p><p>以 GCRoots 的对象做为起点，从起点开始向下搜索，搜索的走过路径叫引用链，引用链上的对象判断为生存，当一个对象到 GCRoots 没有引用链时，判断对象死亡。</p><p>在 JVM 中，做为 GCRoots 的对象：</p><ul><li>虚拟机栈(栈桢中的本地变量表)中的引用的对象</li><li>方法区中的类/静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中 JNI 的引用的对象 </li></ul><hr><h2 id="使用软引用构建敏感数据的缓存"><a href="#使用软引用构建敏感数据的缓存" class="headerlink" title="使用软引用构建敏感数据的缓存"></a>使用软引用构建敏感数据的缓存</h2><h3 id="为什么需要使用软引用"><a href="#为什么需要使用软引用" class="headerlink" title="为什么需要使用软引用"></a>为什么需要使用软引用</h3><p>设想一个雇员信息系统。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览 Web 页面的时候也经常会使用“后退”按钮)。<br>这时我们通常会有两种程序实现方式</p><ul><li>是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的 Java 对象的生命周期贯穿整个应用程序始终。</li><li>是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的 Java 对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。</li><li>很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。</li></ul><p>我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的 Java 对象的引用，必将减少不必要的访问，大大提高程序的运行速度。 </p><h3 id="如何使用软引用"><a href="#如何使用软引用" class="headerlink" title="如何使用软引用"></a>如何使用软引用</h3><p>SoftReference 的特点是它的一个实例保存对一个 Java 对象的软引用，该软引用的存在不妨碍 GC。也就是说，一旦 SoftReference 保存了对一个 Java 对象的软引用后，在垃圾线程对这个 Java 对象回收前，SoftReference 类所提供的 <code>get()</code> 方法返回 Java 对象的强引用。另外，一旦垃圾线程回收该 Java 对象之后，<code>get()</code> 方法将返回 null。</p><p><code>MyObject aRef = new MyObject();</code><br><code>SoftReference aSoftRef = new SoftReference(aRef);</code></p><p>此时，对于这个 MyObject 对象，有两个引用路径，一个是来自 SoftReference 对象的软引用，一个来自变量 aRef 的强引用，所以这个MyObject 对象是强可及对象。 随即，我们可以结束 aReference 对这个MyObjec t实例的强引用:</p><p><code>aRef = null</code></p><p>此后，这个 MyObject 对象成为了软可及对象。如果 GC，并不会因为有一个 SoftReference 的软引用而保留对象。JVM 的垃圾收集线程对软可及对象和其他一般 Java 对象进行了区别对待：软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出 OutOfMemoryError 之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:</p><p><code>MyObject anotherRef=(MyObject)aSoftRef.get();</code></p><p>重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。</p><h3 id="使用-ReferenceQueue-清除失去了软引用对象的-SoftReference"><a href="#使用-ReferenceQueue-清除失去了软引用对象的-SoftReference" class="headerlink" title="使用 ReferenceQueue 清除失去了软引用对象的 SoftReference"></a>使用 ReferenceQueue 清除失去了软引用对象的 SoftReference</h3><p>作为一个 Java 对象，SoftReference 对象除了具有保存软引用的特殊性之外，也具有 Java 对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference 对象的 get() 方法返回 null，但这个 SoftReference 对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量 SoftReference 对象带来的内存泄漏。在 java.lang.ref 包里还提供了 ReferenceQueue。如果在创建 SoftReference 对象的时候，使用了一个 ReferenceQueue 对象作为参数提供给 SoftReference 的构造方法，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">SoftReference ref = <span class="keyword">new</span> SoftReference(aMyObject, queue);</span><br></pre></td></tr></table></figure><p>那么当这个 SoftReference 所软引用的 aMyOhject 被 GC 的同时，ref 所强引用的 SoftReference 对象被列入 ReferenceQueue。也就是说，ReferenceQueue 中保存的对象是 Reference 对象，而且是已经失去了它所软引用的对象的 Reference 对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。</p><p>在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SoftReference ref = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((ref = (EmployeeRef)q.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除ref</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JDK 1.2 以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从 JDK 1.2 版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>抽象</title>
    <link href="https://crowzf.com/posts/9e6fead7/"/>
    <id>https://crowzf.com/posts/9e6fead7/</id>
    <published>2018-04-12T02:19:33.000Z</published>
    <updated>2018-04-17T05:59:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>抽象类与抽象方法</p><a id="more"></a><h2 id="抽象类-Abstract-class"><a href="#抽象类-Abstract-class" class="headerlink" title="抽象类 Abstract class"></a>抽象类 Abstract class</h2><p>通常，我们需要的是子类的对象，而非父类的对象。为了确保一个父类不被创建实例，可将其变为抽象类</p><ul><li>抽象类仍可以放入引用变量</li><li>抽象类不能用<code>new</code>创建实例</li><li>抽象类必须有子类</li></ul><ul><li>抽象类可以有抽象方法，也可以有具体方法</li></ul><hr><h2 id="抽象方法-Abstract-method"><a href="#抽象方法-Abstract-method" class="headerlink" title="抽象方法 Abstract method"></a>抽象方法 Abstract method</h2><ul><li>抽象方法没有函数体，没有{}，其意义在于为抽象类的子类们定义某种协议（大家都必须实现这些方法）。</li><li>抽象方法必须以被重写的方式来实现。</li><li>继承树中第一个具体类必须实现其顶部所有抽象类的所有抽象方法。</li><li>抽象方法必须放入抽象类内，抽象类内可以有非抽象方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽象类与抽象方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>变量</title>
    <link href="https://crowzf.com/posts/13ffbe88/"/>
    <id>https://crowzf.com/posts/13ffbe88/</id>
    <published>2018-04-12T02:19:11.000Z</published>
    <updated>2018-04-17T05:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 变量的类型、默认值与初始化</p><a id="more"></a><h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><ul><li>成员变量(Field) :类体内的变量<ul><li>静态变量：用<code>static</code>修饰，是属于类的。</li><li>实例变量/非静态变量：无<code>static</code>修饰，是属于实例的。</li></ul></li><li>局部变量<ul><li>形参</li><li>方法内的局部变量</li><li>代码块内的局部变量</li></ul></li></ul><p>静态变量的初始化总是先于实例变量的初始化，无关声明顺序，因此：</p><ul><li>两个类变量不能非法向前引用。</li><li>两个实例变量不能非法向前引用。</li><li>但实例变量总是可以引用类变量。</li></ul><hr><h2 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h2><p>实例变量永远都会有默认值。即声明未赋值时依然可以调用。</p><ul><li>基本类型中的整数类型（byte、short、int和long），则值是0。</li><li>基本类型中的浮点类型（float、double），则值是0.0。</li><li>基本类型中的字符类型（char），则值是’\u0000’。</li><li>基本类型中的布尔类型（boolean），则值是false。</li><li>引用类型（类、接口和数组），则为 null</li></ul><p>局部变量没有默认值<br>不指定初始值是菜鸟行为。</p><hr><h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2><h3 id="实例变量的初始化"><a href="#实例变量的初始化" class="headerlink" title="实例变量的初始化"></a>实例变量的初始化</h3><ul><li>定义实例变量时指定初始值</li><li>非静态初始化块中对实例变量指定初始值（对未声明变量直接赋值）</li><li>构造器中对实例变量指定初始值<br>前两项先于第三项。<br>前两项的顺序按照代码中的顺序</li></ul><h3 id="静态变量的初始化"><a href="#静态变量的初始化" class="headerlink" title="静态变量的初始化"></a>静态变量的初始化</h3><ul><li>定义类变量时指定初始值</li><li>静态初始化块中对类变量指定初始值</li><li>静态变量没有默认值，必须显示指定初始值</li></ul><h3 id="Final-静态变量的初始化"><a href="#Final-静态变量的初始化" class="headerlink" title="Final 静态变量的初始化"></a>Final 静态变量的初始化</h3><p>1.定义时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FOO_X = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.在静态初始化块内<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BAR_SIGN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">BAR_SING = (<span class="keyword">double</span>)Math.random()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量的声明类型与对象的实际类型不同时（实际类型是声明类型的子类）<br>当发生上述情况，即变量的编译时类型与运行时类型不同时：</p><ul><li>通过变量访问它引用的对象的实例变量时：该实例变量的值由声明该变量的类型决定。</li><li>通过变量调用它引用的类型的方法时，该方法行为将由它实际引用的对象来决定。</li><li><p>静态变量只有在第一次加载类的时候才会被初始化，而不是每次创建实例都初始化。因此对于该类的所有实例，值都相同。静态变量是所有实例共享的，相同的值。某个对象修改了静态变量的值后，其他对象访问改静态变量得到的是修改后的值。</p></li><li><p>实例变量：每个实例独占一个，1000个对象有1000个实例变量，属于对象。</p></li><li><p>静态变量：每个类只有一个，1000个对象共享同1个，属于类。即使没有对象，也存在着。</p></li><li><p>创建对象前，静态变量必须被初始化完毕。</p></li><li><p>调用类中的静态方法前，静态变量必须被初始化完毕。</p></li><li><p>通过类名（而非对象名）访问静态变量。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> playerCounst; <span class="comment">// int 类型默认值为0</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    playerCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerTestDrive</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            System.out.pintln(Player.playerCount);</span><br><span class="line">            Player one = <span class="keyword">new</span> Player(<span class="string">"Tiger Woods"</span>);</span><br><span class="line">            Systen.out.println(Player.playerCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 变量的类型、默认值与初始化&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://crowzf.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>包装类型</title>
    <link href="https://crowzf.com/posts/7f22fd31/"/>
    <id>https://crowzf.com/posts/7f22fd31/</id>
    <published>2018-04-12T02:18:27.000Z</published>
    <updated>2018-04-17T05:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java 虽然是面向对象编程语言，但是为了编程的方便引入了基本数据类型。为了能将这些基本数据类型当成对象操作，Java 为每个基本数据类型引入了对应的包装类型。</p><a id="more"></a><p>Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换</p><ul><li>boolean—Boolean</li><li>char—Character</li><li>byte—Byte</li><li>short—Short</li><li>int—Integer</li><li>long—Long</li><li>floate—Float</li><li>double—Double</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>; <span class="comment">// 将 int 类型的3自动装箱成 Integer 类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b); <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c); <span class="comment">// true a自动拆箱成 int 类型再和 c 比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 虽然是面向对象编程语言，但是为了编程的方便引入了基本数据类型。为了能将这些基本数据类型当成对象操作，Java 为每个基本数据类型引入了对应的包装类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://crowzf.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>偷资源</title>
    <link href="https://crowzf.com/posts/efaa62e3/"/>
    <id>https://crowzf.com/posts/efaa62e3/</id>
    <published>2018-04-12T02:10:11.000Z</published>
    <updated>2018-04-17T05:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C偷资源</p><a id="more"></a><h2 id="油"><a href="#油" class="headerlink" title="油"></a>油</h2><ul><li>2-2E(1~3SS)</li><li>2-3AEI(1~4SS)</li><li>4-1F(DD练级)</li></ul><hr><h2 id="弹"><a href="#弹" class="headerlink" title="弹"></a>弹</h2><ul><li>2-3AEI(1~4SS)</li></ul><hr><h2 id="钢"><a href="#钢" class="headerlink" title="钢"></a>钢</h2><ul><li>3-2B(1~4SS旗舰168，回避13x2)</li><li>402EG(4~5SS)</li></ul><hr><h2 id="铝"><a href="#铝" class="headerlink" title="铝"></a>铝</h2><ul><li>4-3E(DD练级)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C偷资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>建造配方</title>
    <link href="https://crowzf.com/posts/a32fa04c/"/>
    <id>https://crowzf.com/posts/a32fa04c/</id>
    <published>2018-04-12T02:10:05.000Z</published>
    <updated>2018-04-17T05:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C建造配方</p><a id="more"></a><h2 id="秋云"><a href="#秋云" class="headerlink" title="秋云"></a>秋云</h2><p>250 30 250 31</p><h2 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h2><p>250 30 250 31 Z1</p><h2 id="长门"><a href="#长门" class="headerlink" title="长门"></a>长门</h2><p>400 30 600 30 赤城</p><h2 id="马路油"><a href="#马路油" class="headerlink" title="马路油"></a>马路油</h2><p>1500 1500 2000 1000 1 大和明石</p><h2 id="阿贺野-能代-三隈"><a href="#阿贺野-能代-三隈" class="headerlink" title="阿贺野 能代 三隈"></a>阿贺野 能代 三隈</h2><p>1500 1500 2000 1000 1</p><h2 id="大和-武藏"><a href="#大和-武藏" class="headerlink" title="大和 武藏"></a>大和 武藏</h2><p>4000 7000 7000 2000 20 榛名/大和</p><h2 id="Zara"><a href="#Zara" class="headerlink" title="Zara"></a>Zara</h2><p>3500 4500 4500 2000 20 Libeccio</p><h2 id="Bismarck"><a href="#Bismarck" class="headerlink" title="Bismarck"></a>Bismarck</h2><p>4000 6000 7000 2000 20 Z1</p><h2 id="Saratoga"><a href="#Saratoga" class="headerlink" title="Saratoga"></a>Saratoga</h2><p>4000 2000 5000 7000 20 Iowa</p><h2 id="瑞穗-秋津丸-大凤-神威"><a href="#瑞穗-秋津丸-大凤-神威" class="headerlink" title="瑞穗 秋津丸 大凤 神威"></a>瑞穗 秋津丸 大凤 神威</h2><p>4000 2000 5000 6000 20 Iowa明石</p><h2 id="伊401"><a href="#伊401" class="headerlink" title="伊401"></a>伊401</h2><p>3500 4500 4500 2000 1 榛名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C建造配方&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>支援舰队</title>
    <link href="https://crowzf.com/posts/e305fe87/"/>
    <id>https://crowzf.com/posts/e305fe87/</id>
    <published>2018-04-12T02:06:36.000Z</published>
    <updated>2018-04-17T06:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C支援舰队编成</p><a id="more"></a><h2 id="支援射击"><a href="#支援射击" class="headerlink" title="支援射击"></a>支援射击</h2><ul><li>3BB（3炮1电 / 2炮2电）</li><li>2DD（全炮）</li><li>1CV（全舰爆）</li></ul><hr><h2 id="长距离支援雷击"><a href="#长距离支援雷击" class="headerlink" title="长距离支援雷击"></a>长距离支援雷击</h2><ul><li>目前没用</li></ul><hr><h2 id="航空支援"><a href="#航空支援" class="headerlink" title="航空支援"></a>航空支援</h2><p>支援编成条件：(满足任意一点即可)</p><ul><li><p>(战舰+重巡)=0时，需要(正规空母+轻空母+装甲空母)≥1。但(正规空母+轻空母+装甲空母)=0时，则需要(水母+扬陆舰)≥2 或 (航战+航巡+补给舰)≥2。条件不满足的情况下变为雷击支援</p></li><li><p>(战舰+重巡)≥1时，需要(正规空母+轻空母+装甲空母+水母+扬陆舰)≥2。条件不满足的情况下变为炮击支援</p></li></ul><hr><h2 id="对潜支援哨戒"><a href="#对潜支援哨戒" class="headerlink" title="对潜支援哨戒"></a>对潜支援哨戒</h2><p>在2017年11月17日的更新之后新增加的一种特殊的航空支援，能够优先对敌方潜艇进行攻击（在水面水下混合时候也是）。 构成条件为至少一轻母加上其他可反潜单位（例如带有反潜装备的航巡）的符合航空支援的配置（详细该种类配置见下方各类支援相应配置明细）。<br>特点：</p><ol><li>攻击力计算式现阶段暂时未明，暂时只能建议多带如队长机等较高反潜的攻击机、カ号观测机和三式指挥联络机(对潜)(在有验证结论之后会立即更新)</li><li>在无潜艇的战斗点仍表现为一般航空支援</li><li>在有潜艇的战斗点只会攻击潜艇，即时带了CV也一样，故混合战斗点请慎重考虑</li><li>如同一般航空支援出手一样，支援中所携带的所有反潜机均会对敌方任意一潜艇进行一次攻击</li><li>目前认为爆雷反潜在反潜支援中不会起到作用，故携带海防舰等小型反潜舰艇是没有必要的</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C支援舰队编成&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>练级</title>
    <link href="https://crowzf.com/posts/d84d1c15/"/>
    <id>https://crowzf.com/posts/d84d1c15/</id>
    <published>2018-04-12T02:03:56.000Z</published>
    <updated>2018-04-17T06:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C练级地图与编队</p><a id="more"></a><h2 id="CL-DD-1改CLT-4-3"><a href="#CL-DD-1改CLT-4-3" class="headerlink" title="CL DD 1改CLT 4-3"></a>CL DD 1改CLT 4-3</h2><ul><li>旗舰(反潜套)</li><li>BB(二连)</li><li>2CLT(甲标水听主炮)</li><li>2CVL(开幕强化 反潜强化 彩云 制空&gt;48)</li></ul><hr><h2 id="CA-BB-CV-3-2A"><a href="#CA-BB-CV-3-2A" class="headerlink" title="CA BB CV 3-2A"></a>CA BB CV 3-2A</h2><ul><li>旗舰位<ul><li>CA(2连)</li><li>航巡(2连 熟练舰载机整备员)</li><li>BB(2连 水爆)</li><li>CV(大攻小爆 熟练舰载机整备员)</li></ul></li><li>23号位<ul><li>打手 x 2 红脸替换</li><li>火力 &lt; 100，命中，无2连，无CI，推荐CA/CL/夕立/凌波</li><li>旗舰非BB 要求同上，推荐BBV</li></ul></li><li>4号位：蹭经验<ul><li>随意</li></ul></li><li>5号位：开幕制空<ul><li>CVL 红脸不换 </li><li>中破可用 </li><li>舰爆彩云 </li><li>无其他制空带零战62 </li></ul></li><li>6号位：MT<ul><li>低级168 </li><li>中破可用<br>-1甲标 或 4连酸素</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C练级地图与编队&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>任务</title>
    <link href="https://crowzf.com/posts/5ee7f95d/"/>
    <id>https://crowzf.com/posts/5ee7f95d/</id>
    <published>2018-04-12T02:01:58.000Z</published>
    <updated>2018-04-19T04:47:40.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="补给舰"><a href="#补给舰" class="headerlink" title="补给舰"></a>补给舰</h2><ul><li>2-2 CA + CAV + CLT + CL + DD(81/162)</li><li>2-3(2~4SS) </li><li>4-3 </li><li>5-4</li></ul><hr><h2 id="空母"><a href="#空母" class="headerlink" title="空母"></a>空母</h2><ul><li>2-2(4~6SS) </li><li>2-3(2~4SS) </li><li>4-2 </li><li>5-4</li></ul><hr><h2 id="2图Boss"><a href="#2图Boss" class="headerlink" title="2图Boss"></a>2图Boss</h2><ul><li>2-2(2CVL+4SS) </li><li>2-3(2~4SS) </li></ul><hr><h2 id="3图Boss"><a href="#3图Boss" class="headerlink" title="3图Boss"></a>3图Boss</h2><ul><li>3-4(4~5SS)或不做</li></ul><hr><h2 id="4图Boss"><a href="#4图Boss" class="headerlink" title="4图Boss"></a>4图Boss</h2><ul><li>4-2(4~5SS)或不做</li></ul>]]></content>
    
    <summary type="html">
    
      舰C日常与周常任务
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>远征</title>
    <link href="https://crowzf.com/posts/6104db5e/"/>
    <id>https://crowzf.com/posts/6104db5e/</id>
    <published>2018-04-12T01:59:44.000Z</published>
    <updated>2018-04-17T06:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C针对资源选择远征</p><a id="more"></a><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li>21北方鼠输送作战 1CL + 4DD</li><li>37东京急行 1CL + 5DD</li><li>38东京急行（二）5DD</li></ul><hr><h2 id="油"><a href="#油" class="headerlink" title="油"></a>油</h2><ul><li>5海上护卫任务 1CL + 2DD</li><li>21北方鼠输送作战 1CL + 4DD</li><li>38东京急行（二）5DD</li></ul><hr><h2 id="弹"><a href="#弹" class="headerlink" title="弹"></a>弹</h2><ul><li>2长距离练习航海</li><li>5海上护卫任务 1CL + 2DD</li><li>37东京急行 1CL + 5DD</li></ul><hr><h2 id="钢"><a href="#钢" class="headerlink" title="钢"></a>钢</h2><ul><li>3警备任务</li><li>37东京急行 1CL5DD</li><li>38东京急行（二）5DD</li></ul><hr><h2 id="铝"><a href="#铝" class="headerlink" title="铝"></a>铝</h2><ul><li>5海上护卫任务 1CL + 2DD</li><li>6防空射击演习 </li><li>11铝输送任务 2DD</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C针对资源选择远征&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>阵型</title>
    <link href="https://crowzf.com/posts/71d2d6e7/"/>
    <id>https://crowzf.com/posts/71d2d6e7/</id>
    <published>2018-04-12T01:54:08.000Z</published>
    <updated>2018-04-17T06:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>舰C阵型能力补正</p><a id="more"></a><h2 id="单纵阵"><a href="#单纵阵" class="headerlink" title="单纵阵"></a>单纵阵</h2><ul><li>强化炮雷伤害、雷击命中率</li><li>削弱对潜</li></ul><hr><h2 id="复纵阵"><a href="#复纵阵" class="headerlink" title="复纵阵"></a>复纵阵</h2><ul><li>强化炮击命中率</li><li>强化对空</li><li>各项均衡</li><li>对敌方含有一只 SS</li><li>对水雷舰队</li></ul><hr><h2 id="轮型阵"><a href="#轮型阵" class="headerlink" title="轮型阵"></a>轮型阵</h2><ul><li>大幅强化对空</li><li>大幅强化对潜</li><li>提高援护旗舰发生率</li><li>削弱火力</li><li>大幅削弱雷击命中率</li></ul><hr><h2 id="梯形阵"><a href="#梯形阵" class="headerlink" title="梯形阵"></a>梯形阵</h2><ul><li>玄学</li><li>略微提高炮击回避率</li></ul><hr><h2 id="单横阵"><a href="#单横阵" class="headerlink" title="单横阵"></a>单横阵</h2><ul><li>大幅强化对潜</li><li>小幅幅提高炮击回避率</li><li>小幅提高雷击回避</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C阵型能力补正&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
  <entry>
    <title>带路</title>
    <link href="https://crowzf.com/posts/f5e02980/"/>
    <id>https://crowzf.com/posts/f5e02980/</id>
    <published>2018-04-12T01:02:19.000Z</published>
    <updated>2018-05-03T05:28:01.834Z</updated>
    
    <content type="html"><![CDATA[<p>舰C带路条件</p><a id="more"></a><p>[TOC]</p><h2 id="镇守府海域"><a href="#镇守府海域" class="headerlink" title="镇守府海域"></a>镇守府海域</h2><h3 id="1-1-镇守府正面海域"><a href="#1-1-镇守府正面海域" class="headerlink" title="1-1 镇守府正面海域"></a>1-1 镇守府正面海域</h3><p>全图随机</p><h3 id="1-2-西南诸岛海域"><a href="#1-2-西南诸岛海域" class="headerlink" title="1-2 西南诸岛海域"></a>1-2 西南诸岛海域</h3><p>全图随机</p><h3 id="1-3-制油所地带沿岸"><a href="#1-3-制油所地带沿岸" class="headerlink" title="1-3 制油所地带沿岸"></a>1-3 制油所地带沿岸</h3><p>全图随机，带【21号对空电探】</p><h3 id="1-4-南西诸岛防卫线"><a href="#1-4-南西诸岛防卫线" class="headerlink" title="1-4 南西诸岛防卫线"></a>1-4 南西诸岛防卫线</h3><p>全图随机，加强对空【10cm连装高角炮】【三式弹】【对空电探】</p><h3 id="1-5-【Extra-Operation】镇守府近海"><a href="#1-5-【Extra-Operation】镇守府近海" class="headerlink" title="1-5 【Extra Operation】镇守府近海"></a>1-5 【Extra Operation】镇守府近海</h3><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CVL（大鹰/空船）</td><td style="text-align:center">DE</td></tr><tr><td style="text-align:center">DD/CL</td><td style="text-align:center">DD/CL</td></tr></tbody></table><ul><li>五十铃改二无条件开幕反潜</li><li>DE反潜60可开幕反潜</li><li>其他反潜堆至100，考虑CLT/CT</li></ul><h3 id="1-6-【Extra-Operation】镇守府近海航路"><a href="#1-6-【Extra-Operation】镇守府近海航路" class="headerlink" title="1-6 【Extra Operation】镇守府近海航路"></a>1-6 【Extra Operation】镇守府近海航路</h3><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CL</td><td style="text-align:center">DD</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">DD</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">DD</td></tr></tbody></table><ul><li>五十铃改二对空CI+开幕反潜</li><li>由良改二水爆水战</li><li>秋月级</li><li>(A)-【E(反潜)】-(G)-【F(轮形)】-【B(轮形,大破进击)】-(N)</li><li>旗舰带损管，无消耗</li></ul><h2 id="西南诸岛海域"><a href="#西南诸岛海域" class="headerlink" title="西南诸岛海域"></a>西南诸岛海域</h2><h3 id="2-1-金兰半岛"><a href="#2-1-金兰半岛" class="headerlink" title="2-1 金兰半岛"></a>2-1 金兰半岛</h3><h3 id="2-2-巴士岛海域"><a href="#2-2-巴士岛海域" class="headerlink" title="2-2 巴士岛海域"></a>2-2 巴士岛海域</h3><p>CV/CVL/AV 高概率进入 Boss(81/162)</p><h3 id="2-3-东部奥廖尔海"><a href="#2-3-东部奥廖尔海" class="headerlink" title="2-3 东部奥廖尔海"></a>2-3 东部奥廖尔海</h3><h3 id="2-4-冲之岛海域"><a href="#2-4-冲之岛海域" class="headerlink" title="2-4 冲之岛海域"></a>2-4 冲之岛海域</h3><h3 id="2-5【Extra-Operation】-冲之岛洋面"><a href="#2-5【Extra-Operation】-冲之岛洋面" class="headerlink" title="2-5【Extra Operation】 冲之岛洋面"></a>2-5【Extra Operation】 冲之岛洋面</h3><p>索敌 ≥ 33 才能进入确保进入Boss</p><p>百级以前<br>B-E-I(153/306)-L</p><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">高速BB【金刚】</td><td style="text-align:center">高速BB【比叡】</td></tr><tr><td style="text-align:center">高速BB【榛名】</td><td style="text-align:center">高速BB【雾岛】</td></tr><tr><td style="text-align:center">CV【赤城】</td><td style="text-align:center">CV【加贺】</td></tr></tbody></table><p>百级以后</p><p>B-E-H-L</p><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CL（建议阿武隈改二）</td><td style="text-align:center">DD</td></tr><tr><td style="text-align:center">DD</td><td style="text-align:center">CVL（高搭载 爆战岩井可空确）</td></tr><tr><td style="text-align:center">CVL（推荐瑞凤改二）</td><td style="text-align:center">CVL</td></tr></tbody></table><h2 id="北方海域"><a href="#北方海域" class="headerlink" title="北方海域"></a>北方海域</h2><h3 id="3-1-毛里海"><a href="#3-1-毛里海" class="headerlink" title="3-1 毛里海"></a>3-1 毛里海</h3><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">大船</td><td style="text-align:center">大船</td></tr><tr><td style="text-align:center">大船</td><td style="text-align:center">大船</td></tr><tr><td style="text-align:center">CV</td><td style="text-align:center">CV</td></tr></tbody></table><ul><li>制空 （优）108/（确）216</li></ul><h3 id="3-2-基斯岛海域"><a href="#3-2-基斯岛海域" class="headerlink" title="3-2 基斯岛海域"></a>3-2 基斯岛海域</h3><h3 id="3-3-阿尔方西诺方面"><a href="#3-3-阿尔方西诺方面" class="headerlink" title="3-3 阿尔方西诺方面"></a>3-3 阿尔方西诺方面</h3><h3 id="3-4-北方海域全域"><a href="#3-4-北方海域全域" class="headerlink" title="3-4 北方海域全域"></a>3-4 北方海域全域</h3><h3 id="3-5【Extra-Operation】北方AL海域"><a href="#3-5【Extra-Operation】北方AL海域" class="headerlink" title="3-5【Extra Operation】北方AL海域"></a>3-5【Extra Operation】北方AL海域</h3><ul><li>A - C - F - K</li><li>5舰攻 6舰战 1彩云</li></ul><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CV</td><td style="text-align:center">CV</td></tr><tr><td style="text-align:center">CV</td><td style="text-align:center">CLT</td></tr><tr><td style="text-align:center">SS</td><td style="text-align:center">SS</td></tr></tbody></table><h2 id="西方海域"><a href="#西方海域" class="headerlink" title="西方海域"></a>西方海域</h2><h3 id="4-1-加姆岛攻略作战"><a href="#4-1-加姆岛攻略作战" class="headerlink" title="4-1 加姆岛攻略作战"></a>4-1 加姆岛攻略作战</h3><h3 id="4-2-咖喱洋压制战"><a href="#4-2-咖喱洋压制战" class="headerlink" title="4-2 咖喱洋压制战"></a>4-2 咖喱洋压制战</h3><h3 id="4-2-里兰卡岛空袭"><a href="#4-2-里兰卡岛空袭" class="headerlink" title="4-2 里兰卡岛空袭"></a>4-2 里兰卡岛空袭</h3><h3 id="4-4-加斯加达马海战"><a href="#4-4-加斯加达马海战" class="headerlink" title="4-4 加斯加达马海战"></a>4-4 加斯加达马海战</h3><h3 id="4-5【Extra-Operation】-咖喱洋里看卡岛冲"><a href="#4-5【Extra-Operation】-咖喱洋里看卡岛冲" class="headerlink" title="4-5【Extra Operation】 咖喱洋里看卡岛冲"></a>4-5【Extra Operation】 咖喱洋里看卡岛冲</h3><h2 id="南方海域"><a href="#南方海域" class="headerlink" title="南方海域"></a>南方海域</h2><h3 id="5-1-南方海域前面"><a href="#5-1-南方海域前面" class="headerlink" title="5-1 南方海域前面"></a>5-1 南方海域前面</h3><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">CA</td><td style="text-align:center">CA</td></tr><tr><td style="text-align:center">DD（反潜）</td><td style="text-align:center">DD</td></tr><tr><td style="text-align:center">BB（2连）/CV（攻战战侦）</td><td style="text-align:center">CV</td></tr></tbody></table><h3 id="5-2-珊瑚诸岛海战"><a href="#5-2-珊瑚诸岛海战" class="headerlink" title="5-2 珊瑚诸岛海战"></a>5-2 珊瑚诸岛海战</h3><table><thead><tr><th style="text-align:center">舰队编制</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">BB</td><td style="text-align:center">CLT</td></tr><tr><td style="text-align:center">高火雷CA/CL</td><td style="text-align:center"><strong>CVL</strong></td></tr><tr><td style="text-align:center"><strong>CV</strong></td><td style="text-align:center"><strong>CV</strong></td></tr></tbody></table><ul><li>291</li><li>B/F 潜艇点单横阵/轮形阵</li></ul><h3 id="5-3-萨布岛海域"><a href="#5-3-萨布岛海域" class="headerlink" title="5-3 萨布岛海域"></a>5-3 萨布岛海域</h3><h3 id="5-4-萨门海域"><a href="#5-4-萨门海域" class="headerlink" title="5-4 萨门海域"></a>5-4 萨门海域</h3><h3 id="5-5【Extra-Operation】-萨门海域北方"><a href="#5-5【Extra-Operation】-萨门海域北方" class="headerlink" title="5-5【Extra Operation】 萨门海域北方"></a>5-5【Extra Operation】 萨门海域北方</h3><h2 id="中部海域"><a href="#中部海域" class="headerlink" title="中部海域"></a>中部海域</h2><h3 id="6-1-中部海域哨戒线"><a href="#6-1-中部海域哨戒线" class="headerlink" title="6-1 中部海域哨戒线"></a>6-1 中部海域哨戒线</h3><h3 id="6-2-MS诸岛海域"><a href="#6-2-MS诸岛海域" class="headerlink" title="6-2 MS诸岛海域"></a>6-2 MS诸岛海域</h3><h3 id="6-3-古阿诺环礁海域"><a href="#6-3-古阿诺环礁海域" class="headerlink" title="6-3 古阿诺环礁海域"></a>6-3 古阿诺环礁海域</h3><h3 id="6-4-中部北海域孔雀岛近海"><a href="#6-4-中部北海域孔雀岛近海" class="headerlink" title="6-4 中部北海域孔雀岛近海"></a>6-4 中部北海域孔雀岛近海</h3><h3 id="6-5【Extra-Operation】-KW环礁沿海海域"><a href="#6-5【Extra-Operation】-KW环礁沿海海域" class="headerlink" title="6-5【Extra Operation】 KW环礁沿海海域"></a>6-5【Extra Operation】 KW环礁沿海海域</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;舰C带路条件&lt;/p&gt;
    
    </summary>
    
    
      <category term="舰队 Collection" scheme="https://crowzf.com/tags/%E8%88%B0%E9%98%9F-Collection/"/>
    
  </entry>
  
</feed>
