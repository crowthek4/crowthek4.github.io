<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo 搭建博客]]></title>
    <url>%2Fposts%2Fb6159bfb%2F</url>
    <content type="text"><![CDATA[一、安装1. 安装Node.js Windows Mac 安装Node.js会自动安装npm 2.安装Git Windows Mac 安装Homebrew:/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Git:brew install git 3.安装Hexo1234npm install hexo-cli -g #将hexo安装至默认文件夹，使用全局设置下载hexo init blog #初始化博客文件夹cd blog #进入博客文件夹npm install #安装指定模块，json指定 4.常用插件1npm install hexo-deployer-git --save #集 成 git 部署工具（需配置站点） 二、常用命令1234567hexo n(new) file #在source/_post下面新建一个file.md文件hexo g(generate) #由md文件生成html静态文件hexo s(server) #在本地启动http服务以提供本地预览功能hexo d(deploy) #部署到git(需要插件)hexo render &lt;file&gt; -o &lt;ouput&gt; #渲染指定的md，输出为html格式hexo clean #清除db.json与public里面的内容hexo list &lt;type&gt; #列出指定信息，比如tag，post等等 三、配置站点四、配置主题五、写作1.头部12345678date: 2018-04-14 22:55 #日期status: public #公开title: hexo 安装 #文章名tags: 博客搭建 #标签categlory: 工具 #文章分类top: true #置顶（需要 ）password: abc #查看所需密码（需要 ）abbrlink: xxxxx #永久唯一链接（需要abbrlink插件） 六、深度优化1.文章链接唯一化更改文章题目或者变更文章发布时间时，在默认设置下文章链接会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。安装此插件后，不要在 hexo s 模式下更改文章文件名，否则文章将成空白。 npm install hexo-abbrlink --save 在站点配置文件中查找代码permalink:，将其更改为: permalink: posts/:abbrlink/ # “posts/” 可自行更换 在站点配置文件中添加如下代码： 1234# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 可参照样例以选择： 1234567891011crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html 2.语法优化(1)引用，角标添加角标以注明引用（footnotes），可来回跳转npm install hexo-footnotes --save 安装完毕确认是否生效，如不生效，在站点配置文件中添加如下代码以手动启用：12plubins: - hexo-footnotes]]></content>
      <categories>
        <category>建站</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重载与重写]]></title>
    <url>%2Fposts%2Fd1132592%2F</url>
    <content type="text"><![CDATA[重载overload 与继承无关、与多态无关 一系列同名、同时存在的方法。 参数列表必须不同，依据参数列表决定调用哪个方法。 重载不必遵守父类的多态合同，更加灵活。最常用的是构造器的重载，即一个类有多个构造器（自定构造器，默认构造器等） 返回值类型可以不同 访问修饰符可以不同 可以声明新的或更广泛的检查异常 能够在同一个类中重载方法，也可以在子类中重载方法 重写 Override子类对父类中某个允许访问的方法进行重新编写，得到自己的实现过程。 返回值类型不变，可以是原返回值类型的子类 参数列表不变 访问级别的权限不能比原方法的权限更低 不能抛出新的检查性异常或比原方法更宽泛的异常 声明为 final 的方法不能被重写 声明为 static 的方法不能被重写 同一包中，子类不能重写父类的 private 和 final 方法 不同包中，子类只能重写父类的 非 final 的 public 和 protected 方法 构造方法不能被重写 使用 super 关键字调用父类中的原方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化和反序列化]]></title>
    <url>%2Fposts%2F83d613f6%2F</url>
    <content type="text"><![CDATA[Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：public final void writeObject(Object x) throws IOException 上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：public final Object readObject() throws IOException, ClassNotFoundException 该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。 为了演示序列化在Java中是怎样工作的，我将使用之前教程中提到的Employee类，假设我们定义了如下的Employee类，该类实现了Serializable 接口。 Employee.java 文件代码：12345678910public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int SSN; public int number; public void mailCheck() &#123; System.out.println("Mailing a check to " + name + " " + address); &#125;&#125; 一个类的对象要想序列化成功，必须满足两个条件： 该类必须实现 java.io.Serializable 对象。 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的(transient)。短暂的属性在反序列化时，其值变为类型的默认值。 如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。 序列化对象ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。 该程序执行后，就创建了一个名为 employee.ser 的文件。该程序没有任何输出，但是你可以通过代码研读来理解程序的作用。注意： 当序列化一个对象到文件时， 按照 Java 的标准约定是给文件一个 .ser 扩展名。 SerializeDemo.java 文件代码：1234567891011121314151617181920212223242526import java.io.*;public class SerializeDemo &#123; public static void main(String [] args) &#123; Employee e = new Employee(); e.name = "Reyan Ali”; e.address = "Phokka Kuan, Ambehta Peer”; e.SSN = 11122333; e.number = 101; try &#123; FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser"); ObjectOutputStream out = new ObjectOutputStream(fileOut); out.writeObject(e); out.close(); fileOut.close(); System.out.printf("Serialized data is saved in /tmp/employee.ser"); &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; &#125;&#125; 反序列化对象下面的 DeserializeDemo 程序实例了反序列化，/tmp/employee.ser 存储了 Employee 对象。 DeserializeDemo.java 文件代码：1234567891011121314151617181920212223242526272829303132import java.io.*;public class DeserializeDemo &#123; public static void main(String [] args) &#123; Employee e = null; try &#123; FileInputStream fileIn = new FileInputStream("/tmp/employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); &#125; catch(IOException i) &#123; i.printStackTrace(); return; &#125; catch(ClassNotFoundException c) &#123; System.out.println("Employee class not found"); c.printStackTrace(); return; &#125; System.out.println("Deserialized Employee..."); System.out.println("Name: " + e.name); System.out.println("Address: " + e.address); System.out.println("SSN: " + e.SSN); System.out.println("Number: " + e.number); &#125;&#125; 以上程序编译运行结果如下所示： Deserialized Employee…Name: Reyan AliAddress:Phokka Kuan, Ambehta PeerSSN: 0Number:101 反序列化不会调用构造器，防止属性被初始化 如果对象的继承树上有某个类是不可序列化的，该不可序列化类及继承树向上所有类的构造器会被调用 readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。 注意，readObject() 方法的返回值被转化成 Employee 引用。 当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法]]></title>
    <url>%2Fposts%2Fad01bc3e%2F</url>
    <content type="text"><![CDATA[方法签名 方法名 参数类型 （注意，不包含返回类型） 不包括参数名称 参数列表 参数个数 参数类型 参数顺序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Switch语句]]></title>
    <url>%2Fposts%2F83468082%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[StirngBuilder类]]></title>
    <url>%2Fposts%2F6c2d2fbf%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer类]]></title>
    <url>%2Fposts%2F5a050e8c%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sleep和wait的区别]]></title>
    <url>%2Fposts%2Fa944c3fc%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Runnable和Thread实现多线程的区别]]></title>
    <url>%2Fposts%2F1e9ec59e%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Object类]]></title>
    <url>%2Fposts%2F351cfb72%2F</url>
    <content type="text"><![CDATA[公用方法： boolean equals(Object otherObject)检测两个对象是否指向同一块存储区域。该方法是非常重要的一个方法。 一般equals和==是不一样的，但是在Object中两者是一样的 。子类、自定义的类中一般都要重写这个方法。 .clone()对象拷贝保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。 Class getClass()返回和当前对象相关的 Class 对象final 方法，获得运行时类型 .notify().notifyally()对给定对象进行线程同步 String toString()返回描述该对象值的字符串，在自定义的类中，应该重写这个方法。 .hashCode()哈希查找，可以减少在查找中使用 equals 的次数，重写了 equals 的方法一般都要重写 hashCode 方法。这个方法在一些具有哈希功能的 Collection 中用到。一般必须满足 obj1.equals(obj2) == true。可以推出 obj1.hashCode() == obj2.hashCode()，但是hashCode相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。如果不重写 hashcode()，在 HashSet 中添加两个 equals 的对象，会将两个对象都加入进去。 .wait().wait() 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。线程会释放对象锁.wait() 方法一直等待，直到获得锁或者被中断。.wait(long timeout) 设定一个超时间隔，如果在规定时间内没有获得锁就返回。调用该方法后当前线程进入睡眠状态，直到以下事件发生。（1）其他线程调用了该对象的 .notify() 方法。（2）其他线程调用了该对象的 .notifyAll() 方法。（3）其他线程调用了 interrupt 中断该线程。（4）时间间隔到了。此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException 异常。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2Fposts%2F28877bf%2F</url>
    <content type="text"><![CDATA[概述异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用 System.out.println(11/0) ，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。 异常发生的原因有很多，通常包含以下几大类： 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者 JVM 内存溢出。 这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。- 要理解 Java 异常处理是如何工作的，你需要掌握以下三种类型的异常： 检查性异常: 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常: 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误: 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Exception 类的层次所有的异常类是从 java.lang.Exception 类继承的子类。Exception 类是 Throwable 类的子类。除了 Exception 类外，Throwable 还有一个子类 Error 。 Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在 Java 程序处理的范畴之外。 Error 用来指示运行时环境发生的错误。 例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 在 Java 内置类中(接下来会说明)，有大部分常用检查性和非检查性异常。 Java 内置异常类Java 语言定义了一些异常类在 java.lang 标准包中。 标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。 Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。 ArithmeticException: 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。 ArrayIndexOutOfBoundsException: 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 ArrayStoreException: 试图将错误类型的对象存储到一个对象数组时抛出的异常。 ClassCastException: 当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException: 抛出的异常表明向方法传递了一个不合法或不正确的参数。 IllegalMonitorStateException: 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 IllegalStateException: 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 IllegalThreadStateException: 线程没有处于请求操作所要求的适当状态时抛出的异常。 IndexOutOfBoundsException: 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NegativeArraySizeException: 如果应用程序试图创建大小为负的数组，则抛出该异常。 NullPointerException: 当应用程序试图在需要对象的地方使用 null 时，抛出该异常 NumberFormatException: 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 SecurityException: 由安全管理器抛出的异常，指示存在安全侵犯。 StringIndexOutOfBoundsException: 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。 UnsupportedOperationException: 当不支持请求的操作时，抛出该异常。 下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。 ClassNotFoundException: 应用程序试图加载类时，找不到相应的类，抛出该异常。 CloneNotSupportedException: 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。 IllegalAccessException: 拒绝访问一个类的时候，抛出该异常。 InstantiationException: 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 InterruptedException: 一个线程被另一个线程中断，抛出该异常。NoSuchFieldException请求的变量不存在NoSuchMethodException请求的方法不存在 异常方法下面的列表是 Throwable 类的主要方法: .public String getMessage(): 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 .public Throwable getCause(): 返回一个Throwable 对象代表异常原因。.public String toString(): 使用getMessage()的结果返回类的串级名字。 .public void printStackTrace(): 打印toString()结果和栈层次到System.err，即错误输出流。 .public StackTraceElement [] getStackTrace(): 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 .public Throwable fillInStackTrace(): 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 捕获异常使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：12345try &#123; // 程序代码 &#125; catch(ExceptionName e1) &#123; //Catch 块&#125; Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 实例 下面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常。 ExcepTest.java 文件代码：12345678910111213141516// 文件名 : ExcepTest.javaimport java.io.*;public class ExcepTest &#123; public static void main(String args[]) &#123; try &#123; int a[] = new int[2]; System.out.println("Access element three :" + a[3]); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println("Exception thrown :" + e); &#125; System.out.println("Out of the block"); &#125;&#125; 以上代码编译运行输出结果如下： Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3Out of the block 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。多重捕获块的语法如下所示：123456789try&#123; // 程序代码&#125; catch(异常类型1 异常的变量名1) &#123; // 程序代码&#125; catch(异常类型2 异常的变量名2) &#123; // 程序代码&#125; catch(异常类型2 异常的变量名2) &#123; // 程序代码&#125; 上面的代码段包含了 3 个 catch块。 可以在 try 语句后面添加任意数量的 catch 块。 如果保护代码中发生异常，异常被抛给第一个 catch 块。 如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。 如果不匹配，它会被传递给第二个 catch 块。 如此，直到异常被捕获或者通过所有的 catch 块。 实例该实例展示了怎么使用多重 try/catch。 1234567891011121314151617181920212223242526272829303132try&#123; file = new FileInputStream(fileName); x = (byte) file.read();&#125; catch(IOException i)&#123; i.printStackTrace(); return -1;&#125; catch(FileNotFoundException f) //Not valid! &#123; f.printStackTrace(); return -1;&#125;---## throws/throw 关键字：如果一个方法没有捕获一个检查性异常，那么该方法必须使用 `throws` 关键字来声明。`throws` 关键字放在方法签名的尾部。也可以使用 `throw` 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。下面方法的声明抛出一个 RemoteException 异常：```javaimport java.io.*;public class className &#123; public void deposit(double amount) throws RemoteException &#123; // Method implementation throw new RemoteException(); &#125; //Remainder of class definition&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 1234567891011import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; finally关键字finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 12345678910111213141516171819202122232425262728293031try &#123; // 程序代码&#125; catch(异常类型1 异常的变量名1) &#123; // 程序代码&#125; catch(异常类型2 异常的变量名2) &#123; // 程序代码&#125; finally &#123; // 程序代码&#125;``` ### 实例## ExcepTest.java 文件代码：```javapublic class ExcepTest &#123; public static void main(String args[]) &#123; int a[] = new int[2]; try &#123; System.out.println("Access element three :" + a[3]); &#125; catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println("Exception thrown :" + e); &#125; finally &#123; a[0] = 6; System.out.println("First element value: " +a[0]); System.out.println("The finally statement is executed"); &#125; &#125;&#125; 以上实例编译运行结果如下： Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3First element value: 6The finally statement is executed 注意下面事项：catch 不能独立于 try 存在。在 try/catch 后面添加 finally 块并非强制性要求的。try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。声明自定义异常在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。如果希望写一个检查性异常类，则需要继承 Exception 类。如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。可以像下面这样定义自己的异常类： class MyException extends Exception{} 只继承 Exception 类来创建的异常类是检查性异常类。下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。一个异常类和其它任何类一样，包含有变量和方法。 实例以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作。 InsufficientFundsException.java 文件代码：12345678910111213141516// 文件名InsufficientFundsException.javaimport java.io.*;//自定义异常类，继承Exception类public class InsufficientFundsException extends Exception&#123; //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱 private double amount; public InsufficientFundsException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; 为了展示如何使用我们自定义的异常类，在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常。 CheckingAccount.java 文件代码：123456789101112131415161718192021222324252627282930313233343536373839// 文件名称 CheckingAccount.javaimport java.io.*;//此类模拟银行账户public class CheckingAccount &#123; //balance为余额，number为卡号 private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125; //方法：存钱 public void deposit(double amount) &#123; balance += amount; &#125; //方法：取钱 public void withdraw(double amount) throws InsufficientFundsException &#123; if(amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundsException(needs); &#125; &#125; //方法：返回余额 public double getBalance() &#123; return balance; &#125; //方法：返回卡号 public int getNumber() &#123; return number; &#125;&#125; 下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法。 BankDemo.java 文件代码：//文件名称 BankDemo.java public class BankDemo{ public static void main(String [] args) { CheckingAccount c = new CheckingAccount(101); System.out.println(&quot;Depositing $500...&quot;); c.deposit(500.00); try { System.out.println(&quot;\nWithdrawing $100...&quot;); c.withdraw(100.00); System.out.println(&quot;\nWithdrawing $600...&quot;); c.withdraw(600.00); } catch(InsufficientFundsException e) { System.out.println(&quot;Sorry, but you are short $&quot; + e.getAmount()); e.printStackTrace(); } } } 编译上面三个文件，并运行程序 BankDemo，得到结果如下所示： Depositing $500…Withdrawing $100…Withdrawing $600…Sorry, but you are short $200.0InsufficientFundsExceptionat CheckingAccount.withdraw(CheckingAccount.java:25)at BankDemo.main(BankDemo.java:13) 通用异常在Java中定义了两种类型的异常和错误。JVM(Java虚拟机) 异常： 由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。程序级异常： 由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashCode]]></title>
    <url>%2Fposts%2F600c4239%2F</url>
    <content type="text"><![CDATA[HashCode的特性（1）HashCode的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，HashCode 经常用于确定对象的存储地址。（2）两个对象相同，则 .equals() 方法返回 true ，HashCode 相同。（3）两个对象的 HashCode 相同，两个对象却不一定相同， .equals() 不一定为 true。（4）如果对象的 .equals() 方法被重写，那么对象的 HashCode 也尽量重写。 HashCode作用Java中的集合有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 .equals() 方法可用于保证元素不重复，但如果每增加一个元素就检查一次，若集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次 .equals() 方法。这显然会大大降低效率。 于是，Java 采用了哈希表的原理。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。这样一来，当集合要添加新的元素时，先调用这个元素的 HashCode 方法，就一下子能定位到它应该放置的物理位置上。 （1）如果这个位置上没有元素，它就可以直接存储在这个位置上；（2）如果这个位置上已经有元素了，就调用它的 .equals() 方法与新元素进行比较，相同的话就不存了，散列到其他地址上；（3）（HashCode 相同，.equals() 的结果）不相同的话，也就是发生了Hash key 相同导致冲突的情况，那么就在这个 Hash key 的地方产生一个链表，将所有产生相同 HashCode 的对象放到这个单链表上去，串在一起（很少出现）。这样一来实际调用 .equals() 方法的次数就大大降低了，几乎只需要一两次。 从 Object 角度看，JVM 每 new 一个 Object，它都会将这个 Object 丢到一个 Hash 表中去，这样的话，下次做 Object 的比较或者取这个对象的时候（读取过程），它会根据对象的 HashCode 再从 Hash 表中取这个对象。这样做的目的是提高取对象的效率。若 HashCode 相同再去调用 .equals()。 HashCode实践HashCode 是用于查找使用的，而 .equals() 是用于比较两个对象是否相等的。 例如内存中有这样的位置 ：0 1 2 3 4 5 6 7而我有个类，这个类有个字段叫ID，我要把这个类存放在以上8个位置之一，如果不用 HashCode 而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但以上问题如果用 HashCode 就会使效率提高很多。 定义我们的 HashCode 为 ID％8，比如我们的 ID 为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果 ID 是13，求得的余数是5，那么我们就把该类放在5这个位置。依此类推。 但是如果两个类有相同的 HashCode ，例如9除以8和17除以8的余数都是1，也就是说，我们先通过 HashCode 来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 .equals() 在这个桶里找到我们要的类。 12345678910111213141516171819202122232425262728public class HashTest &#123; private int i; public int getI() &#123; return i; &#125; public void setI(int i) &#123; this.i = i; &#125; public int hashCode() &#123; return i % 10; &#125; public final static void main(String[] args) &#123; HashTest a = new HashTest(); HashTest b = new HashTest(); a.setI(1); b.setI(1); Set&lt;HashTest&gt; set = new HashSet&lt;HashTest&gt;(); set.add(a); set.add(b); System.out.println(a.hashCode() == b.hashCode()); System.out.println(a.equals(b)); System.out.println(set); &#125; &#125; 输出结果为： truefalse 以上这个示例，我们只是重写了 HashCode 方法，从上面的结果可以看出，虽然两个对象的 HashCode 相等，但是实际上两个对象并不是相等，因为我们没有重写 .equals() 方法，那么就会调用 Object 默认的 .equals() 方法，显示这是两个不同的对象。 这里我们将生成的对象放到了 HashSet 中，而 HashSet 中只能够存放唯一的对象，也就是相同的（适用于 .equals() 方法）的对象只会存放一个，但是这里实际上是两个对象ab都被放到了 HashSet 中，这样 HashSet 就失去了他本身的意义了。 下面我们继续重写equals方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HashTest &#123; private int i; public int getI() &#123; return i; &#125; public void setI(int i) &#123; this.i = i; &#125; public boolean equals(Object object) &#123; if (object == null) &#123; return false; &#125; if (object == this) &#123; return true; &#125; if (!(object instanceof HashTest)) &#123; return false; &#125; HashTest other = (HashTest) object; if (other.getI() == this.getI()) &#123; return true; &#125; return false; &#125; public int hashCode() &#123; return i % 10; &#125; public final static void main(String[] args) &#123; HashTest a = new HashTest(); HashTest b = new HashTest(); a.setI(1); b.setI(1); Set&lt;HashTest&gt; set = new HashSet&lt;HashTest&gt;(); set.add(a); set.add(b); System.out.println(a.hashCode() == b.hashCode()); System.out.println(a.equals(b)); System.out.println(set); &#125; &#125; 输出结果如下所示。从结果我们可以看出，现在两个对象就完全相等了，HashSet中也只存放了一份对象。 truetrue]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组列表]]></title>
    <url>%2Fposts%2F7c31d16f%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2Fposts%2Ffc81fbfd%2F</url>
    <content type="text"><![CDATA[字符串 String类 不可变的，不能修改。以便于编译器可以实现字符串共享 通过提取子串再拼接新串的方法间接修改。 检测字符串相等使用 s.equals(t) 方法 不区分大小写检测字符串相等使用 s.equalsIgnoreCase(t) 方法 不能用 == 检测字符串是否相等。== 只检测两个字符串是否在内存的同一个位置上。.equals() 检测二者在内存中的值是否相同。 .length() 方法返回字符串所需的代码单元数量 .codePointCound(0, s.length()) 返回码点数量，即实际长度。 .charAt(n) 返回位置 n 的代码单元 String、StringBuffer与StringBuilder的区别 String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象 StringBuffer 和 StringBuilder 底层是 char[] 实现的 StringBuffer 是线程安全的，而 StringBuilder 是线程不安全的 StringBuilder 比 StringBuffer 有速度优势]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数溢出]]></title>
    <url>%2Fposts%2F704e6497%2F</url>
    <content type="text"><![CDATA[Java 中的 int 总共就 32 位，正数上限的情况首位也只能是 0，其他位都可以是 1（就是 2^31-1 的情况）。但是如果正数过大了，例如 2^31，计算机不得不把首位变成 1，并且很快就忘了这是溢出情况，把它按照正常的方式输出了，于是就成了负的。其实也不能怪它，它没有办法自动处理超过溢出的情况，因为 32 位是固定的，它不能因为溢出而临时扩展到 33 位之类的。 防止溢出的办法是无符号右移一位？？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈帧]]></title>
    <url>%2Fposts%2Fe29258ce%2F</url>
    <content type="text"><![CDATA[一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。栈帧不会被线程共享，也就是说当前栈帧中存在的对象就可以判定为是不会回收的对象]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆栈]]></title>
    <url>%2Fposts%2Faf55460a%2F</url>
    <content type="text"><![CDATA[栈内存 存取速度快 局部变量 方法栈区内的引用变量 基本类型变量 堆内存 new 创建的对象（包括作为对象的值的基本类型变量）和数组 对象在堆内存中不一定是连续的内存，可能是零散的堆内存地址。通过哈希算法换算出一长串哈希数字来表征其在内存中的“物理位置”。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源文件的声明规则]]></title>
    <url>%2Fposts%2F63441ac3%2F</url>
    <content type="text"><![CDATA[当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。 一个源文件中只能有一个public类 一个源文件可以有多个非public类 源文件的名称应该和public类的类名保持一致。 如果一个类定义在某个包中，那么package语句应该在源文件的首行。 如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。 import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。 除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修饰符]]></title>
    <url>%2Fposts%2F9cc58f5a%2F</url>
    <content type="text"><![CDATA[非访问控制修饰符 : final 不可重写，不可更改（不可重新赋值） abstract 抽象 strictfp 访问控制修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × ×]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2Fposts%2F15fc6e8c%2F</url>
    <content type="text"><![CDATA[线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个进程可以有很多线程，每条线程并行执行不同的任务。 创建 Runnable 对象（“工作”）Runnable 是一个接口。写一个类实现该接口，在这个类中定义一条线程要做的事。Runnable threadJob = new MyRunnable(); 创建一个 Thread 对象（“工人”），给它分配 Runnable 对象（“工作”）(NEW 状态)Thread myThread = new Thread(threadJob); 开始该线程，创建新的栈内存给线程(Runnable 状态)myThread.start();线程变为 Runnable 状态后，可以在 Runnable, Running 两种状态中转换，running 状态还可以转换为 blocked 状态，可能的原因有： 等待流中的数据 sleep() 等待一个对象解锁 JVM 的线程管理器似乎是混乱的，无法期待其安排出明确的线程运行顺序（并发问题），因此程序的正确性不应基于线程管理器运行线程的顺序。 并发问题的发生源于两个或更多线程访问同一（实现 Runnable 的类型的）对象的数据。 A 线程访问数据，检查数据，准备操作数据时，进入 sleep() B 线程访问数据，检查数据，对数据进行操作。 A 线程醒来，不知道自己 .sleep() ，未检查数据，直接对数据进行操作。 使用静态方法 sleep() 方法可以确保线程在持续时间内不被转换为 Running。使其他线程可以运行。 解决并发问题—— synchronized 标识符：被 synchronized 标记的方法，在同一时间内只允许一个线程进入并运行完整个方法。运行过程中其它线程不允许进入。 sleep() 方法会抛出 InterruptedException 异常（检查性异常）。所有调用 sleep() 方法必须被包裹在 try/catch 中。或直接声明12345try &#123; Thread.sleep(2000);&#125; catch(InterruptedException ex) &#123; ex.printStackTrace();&#125; 从 sleep() 中恢复过来的线程会处于 Runnable 状态。 Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。下图显示了一个线程完整的生命周期。 新建状态(New):使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于 New 状态。它保持这个状态直到程序 start() 这个线程。 就绪状态(Runnable):当线程对象调用了 start() 方法之后，该线程就进入 Runnable 状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。 运行状态(Running):如果就绪状态的线程获取 CPU 资源，就可以执行 run()* ，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态(Block):如果一个线程执行了 sleep()（睡眠）、suspend()（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入 Block 状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态:一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建一个线程Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 通过继承 Thread 类本身； 通过 Callable 和 Future 创建线程。通过实现 Runnable 接口来创建线程创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。Thread 定义了几个构造方法，下面的这个是我们经常使用的：Thread(Runnable threadOb,String threadName);这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。新线程创建之后，你调用它的 start()方法它才会运行。下面是一个创建线程并开始让它执行的实例：1234567891011121314151617181920212223242526272829303132333435class RunnableDemo implements Runnable &#123; private Thread t; private String threadName; RunnableDemo(String name) &#123; threadName = name; System.out.println("Creating " + threadName); &#125; public void run() &#123; System.out.println("Running " + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println("Thread: " + threadName + ", " + i); Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Thread " + threadName + " interrupted."); &#125; System.out.println("Thread " + threadName + " exiting."); &#125; public void start () &#123; System.out.println("Starting " + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125; &#125; public class TestThread &#123; public static void main(String args[]) &#123; RunnableDemo R1 = new RunnableDemo( "Thread-1"); R1.start(); RunnableDemo R2 = new RunnableDemo( "Thread-2"); R2.start(); &#125; &#125; 通过继承Thread来创建线程创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。1234567891011121314151617181920212223242526272829303132333435class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo(String name) &#123; threadName = name; System.out.println("Creating " + threadName ); &#125; public void run() &#123; System.out.println("Running " + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println("Thread: " + threadName + ", " + i); Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; System.out.println("Thread " + threadName + " interrupted."); &#125; System.out.println("Thread " + threadName + " exiting."); &#125; public void start () &#123; System.out.println("Starting " + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125; &#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( "Thread-1"); T1.start(); ThreadDemo T2 = new ThreadDemo( "Thread-2"); T2.start(); &#125; &#125; Thread 方法下表列出了Thread类的一些重要方法： public void start()使该线程开始执行； Java 虚拟机调用该线程的 run() 方法。 public void run()如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run() 方法；否则，该方法不执行任何操作并返回。 public final void setName(String name)改变线程名称，使之与参数 name 相同。 public final void setPriority(int priority)更改线程的优先级。 public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。 public final void join(long millisec)等待该线程终止的时间最长为 millis 毫秒。 public void interrupt()中断线程。 public final boolean isAlive()测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 public static void yield()暂停当前正在执行的线程对象，并执行其他线程。 public static void sleep(long millisec)在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。线程不会释放对象锁 public static boolean holdsLock(Object x)当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 public static Thread currentThread()返回对当前正在执行的线程对象的引用。 public static void dumpStack()将当前线程的堆栈跟踪打印至标准错误流。 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DisplayMessage implements Runnable &#123; private String message; public DisplayMessage(String message) &#123; this.message = message; &#125; public void run() &#123; while(true) &#123; System.out.println(message); &#125; &#125; &#125;public class GuessANumber extends Thread &#123; private int number; public GuessANumber(int number) &#123; this.number = number; &#125; public void run() &#123; int counter = 0; int guess = 0; do &#123; guess = (int) (Math.random() * 100 + 1); System.out.println(this.getName() + " guesses " + guess); counter++; &#125; while(guess != number); System.out.println("** Correct!" + this.getName() + "in" + counter + "guesses.**"); &#125; &#125;public class ThreadClassDemo &#123; public static void main(String [] args) &#123; Runnable hello = new DisplayMessage("Hello"); Thread thread1 = new Thread(hello); thread1.setDaemon(true); thread1.setName("hello"); System.out.println("Starting hello thread..."); thread1.start(); Runnable bye = new DisplayMessage("Goodbye"); Thread thread2 = new Thread(bye); thread2.setPriority(Thread.MIN_PRIORITY); thread2.setDaemon(true); System.out.println("Starting goodbye thread..."); thread2.start(); System.out.println("Starting thread3..."); Thread thread3 = new GuessANumber(27); thread3.start(); try &#123; thread3.join(); &#125; catch(InterruptedException e) &#123; System.out.println("Thread interrupted."); &#125; System.out.println("Starting thread4..."); Thread thread4 = new GuessANumber(75); thread4.start(); System.out.println("main() is ending..."); &#125; &#125; 运行结果如下，每一次运行的结果都不一样。 1Starting hello thread... Starting goodbye thread... Hello Hello Hello Hello Hello Hello Goodbye Goodbye Goodbye Goodbye Goodbye ....... 通过 Callable 和 Future 创建线程 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。123456789101112131415161718192021222324public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==20) &#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; return i; &#125; &#125; 创建线程的三种方式的对比 采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个主要概念在多线程编程时，你需要了解以下几个概念： 线程同步 线程间通信 线程死锁 线程控制：挂起、停止和恢复 多线程的使用有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2Fposts%2F95495db%2F</url>
    <content type="text"><![CDATA[创建文件对象File f = new File(&quot;MyCode.txt&quot;); 创建文件夹12File dir = new File("Chapter7");`dir.mkdir(); 列出文件夹中的内容123456if (dir.isDirectory()) &#123; String[] dirContents = dir.list(); for (int i = 0; i &lt; dirContents.length; i++) &#123; System.out.println(dirContents[i]); &#125;&#125; 得到文件或文件夹的绝对路径System.out.println(dir.getAbsolutePath()); 删除文件或文件夹（成功则返回true）**boolean isDeleted = f.delete(); 文件对象代表文件或文件夹在磁盘上的文件名和路径，不代表能够访问文件的内容！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位操作]]></title>
    <url>%2Fposts%2F6a503052%2F</url>
    <content type="text"><![CDATA[位操作基础1为真，0为假 与：&amp; 两个位都为 1 时，结果才为 1 或：| 两个位都是 0 时，结果才为 0 异或：^ 两个位相同时为 0，相异为 1 取反：~ 0 变 1，1 变 0 左移：&lt;&lt; 各二进位全部左移若干位，高位丢弃，低位补 0 右移：&gt;&gt; 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移)，有的补 0 (逻辑右移) 在这6种操作符，只有 ~ 取反是单目操作符，其它5种都是双目操作符。 位操作只能用于整形数据，对 float 和 double 类型进行位操作会被编译器报错。 位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像 1，3，5，9 这些 2^i+1 的数字。写成 int a = 1 &lt;&lt; i + 1; 是不对的，程序会先执行 i + 1，再执行左移操作。应该写成 int a = (1 &lt;&lt; i) + 1; 另外位操作还有一些复合操作符，如 &amp;=、|=、 ^=、&lt;&lt;=、&gt;&gt;= 常用位操作小技巧判断奇偶数只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。 if ((a &amp; 1) == 0) 交换两数1234int a = 1, b = 2;a ^= b;b ^= a;a ^= b; 可以这样理解： 第一步 a ^= b 即 a = (a ^ b)； 第二步 b ^= a 即 b = b ^ ( a ^ b)，由于异或运算满足交换律，b ^ ( a ^ b) = b ^ b ^ a。由于一个数和自己异或的结果为 0 并且任何数与 0 异或都会不变的，所以此时 b 被赋上了 a 的值； 第三步 a ^= b 就是 a = a ^ b，由于前面二步可知 a = ( a ^ b)，b=a，所以 a = a ^ b 即 a = ( a ^ b ) ^ a。故 a 会被赋上 b 的值。 变换符号123// 取反后加 1// 注意计算机以补码表示，因此是对补码取反System.out.println(~a + 1); 求绝对值123// int 是32位，右移31位即可使符号位落入最后一位int i = a &gt;&gt; 31;System.out.println(i == 0 ? a : (~a + 1)); 现在再分析下。对于任何数，与 0 异或都会保持不变，与 -1 即 0xFFFFFFFF 异或就相当于取反。因此，a 与 i 异或后再减 i（因为 i 为 0 或 -1，所以减 i即是要么加 0要么加 1）也可以得到绝对值。所以可以对上面代码优化下： 12int j = a &gt;&gt; 31;System.out.println((a ^ j) - j); 注意这种方法没用任何判断表达式. 位操作与空间压缩筛素数(质数)法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码： 12345678910111213141516int max = 100;boolean[] flags = new boolean[max];int[] primes = new int[max / 3 + 1];int pi = 0;for (int m = 2; m &lt; max ; m ++) &#123; if (!flags[m]) &#123; primes[pi++] = m; for(int n = m; n &lt; max; n += m) &#123; flags[n] = true; &#125; &#125;&#125;System.out.println(Arrays.toString(primes)); 在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之七。 在数组中把指定位置变为1下面考虑下如何在数组中对指定位置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将 1 向左移位后与其相或来达到在指定位上置1的效果，代码如下所示： 1234// 在一个数指定位上置1int e = 0;e |= 1 &lt;&lt; 10;System.out.println(e); 判断指定位置是0还是1同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。 12345//判断指定位上是0还是1if ((e &amp; (1 &lt;&lt; 10)) != 0)System.out.println("指定位上为1");elseSystem.out.println("指定位上为0"); 扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作： 1234567891011int[] bits = new int[40 / 32 + 1];for (int m = 0; m &lt; 40; m += 3) &#123; bits[m / 32] |= (1 &lt;&lt; (m % 32));&#125;// 输出整个bitsfor (int m = 0; m &lt; 40; m++) &#123; if (((bits[m / 32] &gt;&gt; (m % 32)) &amp; 1) != 0) System.out.print('1'); else System.out.print('0');&#125; log 信息 1001001001001001001001001001001001001001 可以看出该数组每 3 个就置成了1，证明我们上面对数组进行位操作的方法是正确的。因此可以将上面筛素数方法改成使用位操作压缩后的筛素数方法： 12345678910111213int[] flags2 = new int[max / 32 + 1];int [] primes = new int[max / 3 + 1];pi = 0;for (int m = 2; m &lt; max ; m ++) &#123; if ((((flags2[m / 32] &gt;&gt; (m % 32)) &amp; 1) == 0)) &#123; primes[pi++] = m; for(int n = m; n &lt; max; n += m) &#123; flags2[n / 32] |= (1 &lt;&lt; (n % 32)); &#125; &#125;&#125;System.out.println(Arrays.toString(primes)); log 信息为 [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0] 获取 int 型最大值123// 由于优先级关系，括号不可省略System.out.println((1 &lt;&lt; 31) - 1);// 2147483647， System.out.println(~(1 &lt;&lt; 31));// 2147483647 获取 int 型最小值123// 2. 获得int型最小值System.out.println(1 &lt;&lt; 31);System.out.println(1 &lt;&lt; -1); 获取 long 型最大值System.out.println(((long)1 &lt;&lt; 127) - 1); 乘以2System.out.println(10&lt;&lt;1); 除以2（负奇数运算不可用）System.out.println(10&gt;&gt;1); 乘以 2 的 m 次幂System.out.println(10&lt;&lt;2); 除以 2 的 m 次幂System.out.println(16&gt;&gt;2); 判断一个数的奇偶性12System.out.println((10 &amp; 1) == 1);System.out.println((9 &amp; 1) == 1); 不用临时变量交换两个数（面试常考）123a ^= b;b ^= a;a ^= b; 取绝对值（某些机器上，效率比n&gt;0 ? n:-n 高）12345int n = -1;System.out.println((n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31));/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1若n为正数 n^0-0数不变，若n为负数n^-1 需要计算n和-1的补码，异或后再取补码，结果n变号并且绝对值减1，再减去-1就是绝对值 */ 取两个数的最大值（某些机器上，效率比a&gt;b ? a:b高）System.out.println(b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31)); 取两个数的最小值（某些机器上，效率比a&gt;b ? b:a高）System.out.println(a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31)); 判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)System.out.println((a ^ b) &gt; 0); 计算2的n次方 n &gt; 0System.out.println(2&lt;&lt;(n-1)); 判断一个数n是不是2的幂1234// System.out.println((n &amp; (n - 1)) == 0);/*如果是2的幂，n一定是100... n-1就是1111....所以做与运算结果为0*/ 求两个整数的平均值System.out.println((a+b) &gt;&gt; 1); 从低位到高位,取n的第m位12int m = 2;System.out.println((n &gt;&gt; (m-1)) &amp; 1); 从低位到高位.将n的第m位置为1123System.out.println(n | (1&lt;&lt;(m-1)));/*将1左移m-1位找到第m位，得到000...1...000n在和这个数做或运算*/ 从低位到高位,将n的第m位置为0123System.out.println(n &amp; ~(0&lt;&lt;(m-1)));/* 将1左移m-1位找到第m位，取反后变成111...0...1111n再和这个数做与运算*/]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2Fposts%2F340249a9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fposts%2F28239a8d%2F</url>
    <content type="text"><![CDATA[抽象 Abstract将一类对象的共同特征总结出来构造类的过程。 ##继承 子类从父类处继承信息 继承性是子类共享其父类数据和方法的机制。它由类的派生功能体现。一个类直接继承其他类的全部描述，同时可修改和扩充。继承具有传递性。继承分为单继承（一个子类有一父类）和多重继承（一个类有多个父类）。类的对象是各自封闭的，如果没继承性机制，则类的对象中的数据、方法就会出现大量重复。继承不仅支持系统的可重用性，而且还促进系统的可扩充性。 封装隐藏具体操作，只提供简单的编程接口和返回数据 封装是一种信息隐蔽技术，它体现于类的说明，是对象的重要特性。封装使数据和加工该数据的方法（函数）封装为一个整体，以实现独立性很强的模块，使得用户只能见到对象的外特性（对象能接受哪些消息，具有哪些处理能力），而对象的内特性（保存内部状态的私有数据和实现加工能力的算法）对用户是隐蔽的。封装的目的在于把对象的设计者和对象的使用者分开，使用者不必知晓其行为实现的细节，只须用设计者提供的消息来访问该对象。 Getter 返回实例变量的值Setter 设定实例变量的值 为了避免数据泄露，导致变量的值可以通过点运算符来存取，应该使用 Setter 来给实例设置变量。强迫所有变量都必须调用 Setter 才能获取值。 实例变量应设置为 privateSetter 和 Getter 设置为 public 多态 Polymorphism子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征。这意味着同一个类型的对象在执行同一方法时，可能表现出多种行为特征建立一个装父类的数组，可以放入不同的子类对象，每个子类对象对父类的同一方法可作出不同响应将父类作为方法的参数类型，或返回值类型，或数组类型，来避免为每一个子类创建新的方法多态意味着多种形态。一个对象既是所属类的实例，也是 Object 类的实例 对象根据所接收的消息而做出动作。同一消息被不同的对象接受时可产生完全不同的行动，这种现象称为多态性。利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消息的对象自行决定，如是，同一消息即可调用不同的方法。例如：同样是 run 方法，飞鸟调用时是飞，野兽调用时是奔跑。多态性的实现受到继承性的支持，利用类继承的层次关系，把具有通用功能的协议存放在类层次中尽可能高的地方，而将实现这一功能的不同方法置于较低层次，这样，在这些低层次上生成的对象就能给通用消息以不同的响应。在 OOPL 中可通过在派生类中重定义基类函数（定义为重载函数或虚函数）来实现多态性。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举]]></title>
    <url>%2Fposts%2F633a03ca%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2Fposts%2F79666db%2F</url>
    <content type="text"><![CDATA[链表概述链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。1234public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable,java.io.Serializable&#123; &#125; LinkedList继承自AbstractSequenceList，实现了 List、Deque、Cloneable、java.io.Serializable接口。AbstractSequenceList 提供了 List 接口骨干性的实现以减少实现 List 接口的复杂度，Deque 接口定义了双端队列的操作。单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node 。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。上图中最左边的节点即为头节点（Head），（头节点也可以包含数据）。新增节点出现在头节点右侧，紧挨头节点。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明： 单项链表的实现1234567public class LinkList&lt;T&gt; &#123; // 定义头节点 LinkList&lt;T&gt; head; // 定义节点类 private static &#125; 链表的应用查找单链表的中间节点采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点。123456789101112131415/** * 查找单链表的中间节点 * * @param head * @return */public Node SearchMid(Node head) &#123; Node p = this.head, q = this.head; while (p != null &amp;&amp; p.next != null &amp;&amp; p.next.next != null) &#123; p = p.next.next; q = q.next; &#125; System.out.println("Mid:" + q.data); return q; &#125; 查找倒数第k个元素采用两个指针P1,P2，P1先前移K步，然后P1、P2同时移动，当p1移动到尾部时，P2所指位置的元素即倒数第k个元素 。123456789101112131415161718192021/** * 查找倒数 第k个元素 * @param head * @param k * @return */public Node findElem(Node head, int k) &#123; if (k &lt; 1 || k &gt; this.length()) &#123; return null; &#125; Node p1 = head; Node p2 = head; // 前移k步 for (int i = 0; i &lt; k; i++) p1 = p1.next; while (p1 != null) &#123; p1 = p1.next; p2 = p2.next; &#125; return p2;&#125; 对链表进行排序1234567891011121314151617181920212223/** * 排序 * * @return */ public Node orderList() &#123; Node nextNode = null; int tmp = 0; Node curNode = head; while (curNode.next != null) &#123; nextNode = curNode.next; while (nextNode != null) &#123; if (curNode.data &gt; nextNode.data) &#123; tmp = curNode.data; curNode.data = nextNode.data; nextNode.data = tmp; &#125; nextNode = nextNode.next; &#125; curNode = curNode.next; &#125; return head;&#125; 删除链表中的重复节点12345678910111213141516/** * 删除重复节点 */public void deleteDuplecate(Node head) &#123; Node p = head; while (p != null) &#123; Node q = p; while (q.next != null) &#123; if (p.data == q.next.data) &#123; q.next = q.next.next; &#125; else q = q.next; &#125; p = p.next; &#125;&#125; 从尾到头输出单链表，采用递归方式实现1234567891011/** * 从尾到头输出单链表，采用递归方式实现 * * @param pListHead */public void printListReversely(Node pListHead) &#123; if (pListHead != null) &#123; printListReversely(pListHead.next); System.out.println("printListReversely:" + pListHead.data); &#125;&#125; 判断链表是否有环，有环情况下找出环的入口节点123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 判断链表是否有环，单向链表有环时，尾节点相同 * * @param head * @return*/public boolean IsLoop(Node head) &#123; Node fast = head, slow = head; if (fast == null) &#123; return false; &#125; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) &#123; System.out.println("该链表有环"); return true; &#125; &#125; return !(fast == null || fast.next == null);&#125;/** * 找出链表环的入口 * * @param head * @return */public Node FindLoopPort(Node head) &#123; Node fast = head, slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) break; &#125; if (fast == null || fast.next == null) return null; slow = head; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return slow;&#125; 添加节点的方法很明显违反了单链表先进后出的原则12345public void addNode(int d)&#123; Node newNode = new Node(d); newNode.next = head; head = newNode;&#125; 枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。 例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。 1234567891011class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size;&#125; public class FreshJuiceTest &#123; public static void main(String []args)&#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; &#125;&#125; 注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。 数组JAVA 数组是静态的，声明后长度不可改变，仅数值可改变 数组初始化的两种方式 静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。 动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。 【初始化数组时，不要同时使用静态和动态方法】 数组变量是引用变量数组变量不是数组本身，它指向堆内存中的数组对象。改变数组变量所引用的数组，可以造成数组长度可变的假象 多维数组即数组套数组int[][] 数组列表 ArrayListArrayList 类扩展 AbstractList，并实现了 List 接口。支持 ArrayList 动态数组根据需要可以增长。 标准的 Java 数组是一个固定长度的。创建数组后，他们不能生长或缩小，这意味着必须事先知道数组将容纳多少元素。 数组列表是用初始大小创建。但添加元素时，会自动放大。删除元素时，会自动缩小。 ArrayList是泛型类，应指定其内部所保存的元素类型。使用&lt;类型&gt;接在ArrayList后面 构造函数。 ArrayList&lt;E&gt;()构造一个空数组列表 ArrayList&lt;E&gt;(int initalCapacity) 用指定容量构造一个空数组列表 ArrayList(Collection c)建立一个与集合c 的元素初始化一个数组列表。 菱形语法ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;()`ArrayList staff = new ArrayList&lt;&gt;(); 方法除了从它的父类继承的方法，ArrayList中定义了以下方法： void add(int index, Object element)插入指定位置的索引在此列表中的指定元素。如果指定的索引超出range (index &lt; 0 || index &gt; size())，抛出IndexOutOfBoundsException异常。 boolean add(Object o)将指定的元素添加到ArrayList的末尾，永远返回ture。 void ensureCapacity(int Capacity)确保ArrayList在不重新分配存储空间的情况下就能够保存给定数量的元素。 void trimToSize()将ArrayList的存储容量削减到当前尺寸。 boolean addAll(Collection c)所有追加指定collection中的元素添加到此列表的结尾，因为它们是由指定collection的迭代器返回的顺序。，如果指定集合为null，抛出NullPointerException异常。 boolean addAll(int index, Collection c)插入所有指定集合中的元素插入此列表，开始在指定的位置。抛出NullPointerException异常，如果指定集合为null。 void clear()移除此列表中的元素。 Object clone()返回此ArrayList浅表副本。 boolean contains(Object o)如果此列表包含指定的元素返回true。更正式地说，当且仅当此列表包含至少一个元素e，使得返回true (o==null ? e==null : o.equals(e)). Object get(int index)返回此列表中指定位置的元素。抛出IndexOutOfBoundsException异常，如果指定的索引超出range (index &lt; 0 || index &gt;= size()). int indexOf(Object o)返回索引中的指定元素第一次出现的这个名单，或者-1，如果列表中不包含该元素。 int lastIndexOf(Object o)返回索引中的指定元素中最后出现的这个名单，或者-1，如果列表中不包含该元素。 Object remove(int index)移除元素在此列表中的指定位置。如果索引超出 range (index &lt; 0 || index &gt;= size()) 抛出一个IndexOutOfBoundsException。 protected void removeRange(int fromIndex, int toIndex)从这个列表中删除所有索引为fromIndex（包括）和toIndex，独占的元素。 Object set(int index, Object element)替换元素在与指定元素在此列表中的指定位置。抛出IndexOutOfBoundsException异常，如果指定的索引超出 range (index &lt; 0 || index &gt;= size()). int size()返回此列表中的元素数。 Object[] toArray()返回包含所有在此列表中正确的顺序元素的数组。抛出NullPointerException异常如果指定数组为null。 Object[] toArray(Object[] a)返回包含所有在此列表中正确的顺序元素的数组;返回数组的运行时类型是指定数组。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收器]]></title>
    <url>%2Fposts%2Ffe8a6aab%2F</url>
    <content type="text"><![CDATA[失去引用的对象将被 GC 列入“可回收名单”，但不一定立即回收。 1.标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片 2.标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率 3.复制回收法：把现有内存空间分成两部分，GC 运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。 4.分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法 5.引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程 6.对象引用遍历（现在大多数 JVM 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态变量]]></title>
    <url>%2Fposts%2F179f63b0%2F</url>
    <content type="text"><![CDATA[静态变量 静态变量只有在第一次加载类的时候才会被初始化，而不是每次创建实例都初始化。因此对于该类的所有实例，值都相同。静态变量是所有实例共享的，相同的值。某个对象修改了静态变量的值后，其他对象访问改静态变量得到的是修改后的值。 实例变量：每个实例独占一个，1000个对象有1000个实例变量，属于对象。 静态变量：每个类只有一个，1000个对象共享同1个，属于类。即使没有对象，也存在着。 创建对象前，静态变量必须被初始化完毕。 调用类中的静态方法前，静态变量必须被初始化完毕。 通过类名（而非对象名）访问静态变量。 123456789101112131415class Player &#123; static int playerCounst; // int 类型默认值为0 private String name; public Player(String n) &#123; name = n; playerCount++; &#125; public class PlayerTestDrive &#123; public static void main(String[] args) &#123; System.out.pintln(Player.playerCount); Player one = new Player("Tiger Woods"); Systen.out.println(Player.playerCount); &#125; &#125;&#125; 静态方法 静态方法不能对实例进行操作，不能使用实例变量的值。因此调用静态方法时，不需要对象，直接使用类名。 123int x = Math.round(42.2);int y = Math.min(56, 12);int z = Math.abs(-343); 需要静态方法的场合： 一个方法不需要访问对象状态，其所有参数都是通过显示参数提供（例如：Math.pow)。 一个方法只需要访问类的静态变量。 使用静态工厂方法来构造对象。 静态方法可以在堆内存中没有类的实例的情况下调用。 静态方法可以访问静态变量。 但使用引用变量调用静态方法是允许的，这会造成混淆。不推荐。 拥有静态方法的类不应该被初始化，这可以通过把构造器声明为 Private 来实现。但不意味着无法被初始化，例如拥有 main 方法的类。 静态方法不能调用非静态方法，因为非静态方法通常会有实例变量。即使方法中没有使用实例变量也不可以。避免日后会修改该方法导致使用实例变量，或子类重写该方法导致使用实例变量。 静态工厂方法不通过new，而是用一个静态方法来对外提供自身实例的方法。 Fragment 静态工厂方法的优势]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口Interface]]></title>
    <url>%2Fposts%2F990f7b7d%2F</url>
    <content type="text"><![CDATA[接口（英文：Interface），在 JAVA 编程语言中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过实现接口的方式，从而实现接口的抽象方法 用于强调某个类应实现的功能。 接口并不是类，无法被实例化。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与抽象类一个类只能继承一个抽象类。但可以实现多个接口。 接口与类相似点： 一个接口可以有多个方法 接口文件保存在 .java 结尾的文件中，文件名使用接口名 接口的字节码文件保存在 .class 结尾的文件中 接口相应的字节码文件必须在与包名称相匹配的目录结构中 接口与类的区别： 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法 接口不能包含成员变量，除了 static 和 final 变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错） 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误） 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法 抽象类和接口的区别 接口强调要实现的功能，抽象类强调继承（所属）关系。 抽象类中的方法可以有方法体（非抽象方法），但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口的声明接口的声明语法格式如下： 1234&lt;可见度&gt; interface 接口名称 extends &lt;其他的类名&gt; &#123;// 声明变量// 抽象方法&#125; Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。 1234567// 文件名 : NameOfInterface.java// 引入包import java.lang.*;public interface NameOfInterface&#123;//任何类型 final, static 字段//抽象方法&#125; 1234interface Animal &#123; public void eat(); public void travel();&#125; 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。实现一个接口的语法，可以使用这个公式： 1234567891011121314151617181920/* 文件名 : MammalInt.java */public class MammalInt implements Animal &#123; public void eat() &#123; System.out.println("Mammal eats"); &#125; public void travel() &#123; System.out.println("Mammal travels"); &#125; public int noOfLegs() &#123; return 0; &#125; public static void main(String args[]) &#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920// 文件名: Sports.javapublic interface Sports &#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125;// 文件名: Football.javapublic interface Football extends Sports &#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125;// 文件名: Hockey.javapublic interface Hockey extends Sports &#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey 接口自己声明了四个方法，从 Sports 接口继承了两个方法，这样，实现 Hockey 接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于 Sports 接口。 接口的多继承在 Java 中，类的多继承是不合法，但接口允许多继承。在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。如下所示 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法 标识接口最常用的继承接口是没有包含任何方法的接口，它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 12package java.util;public interface EventListener&#123;&#125; 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：建立一个公共的父接口：正如 EventListener 接口，这是由几十个其他接口扩展的 Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener 接口，Java 虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型：这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本类型Primitive_type]]></title>
    <url>%2Fposts%2F4d6a6177%2F</url>
    <content type="text"><![CDATA[byte byte数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一； 例子：byte a = 10; byte b = -50 short short 数据类型是 16位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； short数据类型也可以像byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000; short r = -20000 int int数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 通常，整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000; int b = -200000 long long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。 “L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 应加上 f 或 F 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double 类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char char类型是一个单一的 16 位 Unicode 字符； 用单引号赋值 最小值是 \u0000（即为0）； 最大值是 \uffff（即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 有些 Unicode 字符可以用一个 char 值描述，另外一些 Unicode 字符则需要两个 char 值 16位的 char 类型最多只能描述 65536 个代码值，现在已经不够了 码点 (code point)是编码表中某个字符对应的代码值，采用十六进制书写，前缀 U+。如 A 的码点是 U+0041 码点分为17个 代码级别 (code plane)。第一个代码级别是 基本的多语言级别 (basic multilingual plane)。码点从 U+0000 到 U+FFFF ，包括经典的 Unicode 代码。其余16个代码级别从 U+10000 到 U+10FFFF，包括一些 辅助字符 (supplementary character)。 基本的多语言级别中，每个字符用16位表示，称为 代码单元(code unit) ，辅助字符采用一对连续的代码单元进行编码。这样构成的编码值落入基本的多语言级别中空闲的 2048 字节内，被称为 替代区域(surrogate area) 。【U+D800 ~ U+DBFF用于第一个代码单元(共1024字节），U+DC00 ~ U+DFFF（共1024字节）用于第二个代码单元】。这样可以知道一个代码单元是一个字符的编码，还是一个辅助字符的第一或第二部分。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字]]></title>
    <url>%2Fposts%2Ffe7c7d2d%2F</url>
    <content type="text"><![CDATA[下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。 类别 关键字 说明 访问控制 private 私有的 protected 受保护的 public 公共的 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩允,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非Java实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供switch选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 null 空 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造过程]]></title>
    <url>%2Fposts%2F92e0508e%2F</url>
    <content type="text"><![CDATA[内存分配Dog myDog = new Dog(); 声明一个引用变量 ：要求 Java 虚拟机分配空间给一个引用变量 ，这个引用变量是 Dog 类型，叫做 myDog。存储在变量所属的方法栈中。 创建对象 ：要求 Java 虚拟机分配 堆空间 给新建立的 Dog 对象。这里的 new 语法是在调用类的构造器，如果构造器中有代码，可以运行。 连接对象和引用： 将获取 Dog 对象的方法以字节形式放进引用变量中。换言之，引用变量(遥控器)是获得对象的某种神秘方法，而不是变量本身。 同一个 Java 虚拟机的引用变量是固定大小。 对象的初始化过程 调用Object类的非静态初始化块 调用Object类的构造器 调用父类的非静态初始化块 调用父类的构造器 调用非静态初始化块 调用构造器 （如果有super()）根据实参列表决定调用哪个父类构造器 （如果有this()）调用同类中指定的构造器 构造器 对象要先运行构造器，才能赋值给一个引用。 构造器必须与类同名。 构造器没有返回值。而函数方法必须有返回值。 一个类可以有多个构造器：重载构造器 默认构造器public Duck(){} 自定构造器public Duck(int duckSize) {} 构造器中的代码可以让对象在被创建时进行一些自定义。如打印信息等。 对于一个在不同对象中，值会发生变化的实例变量，考虑在构造器中为实例变量赋值，一来可以避免创建对象后还要调用 setter 方法赋值。二来可以使实例变量从出生就有值，避免出现赋值前的“真空期”（未赋值时由系统指定默认值）。 如果对象必须等待其内部某个实例变量被赋值后才能使用，期待创建对象的人调用 setter 方法来赋值是不靠谱的。应该将这样的变量作为参数传入类的构造器。使得用户在创建实例时，必须传入参数的值才能构造。 12345678910111213141516public class Duck &#123; // 假设该参数必须赋值 int size; // 默认构造器（无参构造器） public Duck() &#123; // 默认值 size = 27; &#125; // 自定构造器 public Duck(int duckSize) &#123; // 通过参数赋值 size = duckSize; &#125;&#125; 只有当类缺少自定构造器时，编译器才会自动给与默认构造器。换言之，如果有自定构造器，还必须自行编写一个默认构造器。 创建实例时，对象的继承树上的所有构造器都必须运行。对象的构造器会沿继承树向上调用所有父类的构造器，直到 Object 类的构造器。编译器隐式地使用 super()。 如果你没有给类提供构造器，编译器会自动提供一个 super()。如果你提供了构造器，编译器会在每个构造器的第一行加入 super()。 抽象类型也拥有构造器，即使不能创建抽象类型的实例，但创建其子类的实例时还是要运行父类的构造器。因为子类中可能会用到父类中定义的变量的值。 使用 super() 来调用父类的构造器，super()必须放在构造器的第一行。 在构造器中调用其他构造器并传入参数：使用 this(arg) 方法。 this(args) 方法只能用在构造器中，且必须是构造器的第一行语句。 构造器中，super() 和 this() 只能选用其一。 极端情况下的父类访问子类的实例变量的方法this 处于构造器中时，代表的是正在初始化的 Java 对象。 子类构造器调用父类构造器，父类构造器中有 this，这个 this 代表的是子类，因为当时父类构造器中的代码是放在子类构造器中执行的。 当变量的编译时类型和运行时类型不同时 特殊情况下父类调用被子类重写的方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式指定]]></title>
    <url>%2Fposts%2F7d9efe37%2F</url>
    <content type="text"><![CDATA[% [argument number][flags][width][.precision] type %和 type 是必须的 [argument number]超过一个参数时，指定是哪个参数。 [flags]特殊格式选项，如加入“，”或把负数放进括号里 [width]最少需要的字符数。如果数字长于它，则正常显示；如果短于它，则用0填充。例如0096 [precision]小数点后的精度 格式化字符串 %d：decimal 兼容int, byte, short, char %f：floating point number 兼容float 和 double %x：hexadecimal 十六进制 %c：character 字符 %tc：完整时间（星期 月 日 时间 MST时区？ß 年） %tr：时间 %ta：星期几 %tB：月份 %td：几号 12Date today = new Date();String.format(“%A, %&lt;tB, %td", today);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分支语句]]></title>
    <url>%2Fposts%2Fdc306f3e%2F</url>
    <content type="text"><![CDATA[The break StatementThe break statement has two forms: labeled and unlabeled. You saw the unlabeled form in the previous discussion of the switch statement. You can also use an unlabeled break to terminate a for, while, or do-while loop, as shown in the following BreakDemo program: 1234567891011121314151617181920212223242526class BreakDemo &#123; public static void main(String[] args) &#123; int[] arrayOfInts = &#123; 32, 87, 3, 589, 12, 1076, 2000, 8, 622, 127 &#125;; int searchfor = 12; int i; boolean foundIt = false; for (i = 0; i &lt; arrayOfInts.length; i++) &#123; if (arrayOfInts[i] == searchfor) &#123; foundIt = true; break; &#125; &#125; if (foundIt) &#123; System.out.println("Found " + searchfor + " at index " + i); &#125; else &#123; System.out.println(searchfor + " not in the array"); &#125; &#125;&#125; This program searches for the number 12 in an array. The break statement, shown in boldface, terminates the for loop when that value is found. Control flow then transfers to the statement after the for loop. This program’s output is: Found 12 at index 4 An unlabeled break statement terminates the innermost switch, for, while, or do-while statement, but a labeled break terminates an outer statement. The following program, BreakWithLabelDemo, is similar to the previous program, but uses nested for loops to search for a value in a two-dimensional array. When the value is found, a labeled break terminates the outer for loop (labeled “search”): 1234567891011121314151617181920212223242526272829303132class BreakWithLabelDemo &#123; public static void main(String[] args) &#123; int[][] arrayOfInts = &#123; &#123; 32, 87, 3, 589 &#125;, &#123; 12, 1076, 2000, 8 &#125;, &#123; 622, 127, 77, 955 &#125; &#125;; int searchfor = 12; int i; int j = 0; boolean foundIt = false; search: for (i = 0; i &lt; arrayOfInts.length; i++) &#123; for (j = 0; j &lt; arrayOfInts[i].length; j++) &#123; if (arrayOfInts[i][j] == searchfor) &#123; foundIt = true; break search; &#125; &#125; &#125; if (foundIt) &#123; System.out.println("Found " + searchfor + " at " + i + ", " + j); &#125; else &#123; System.out.println(searchfor + " not in the array"); &#125; &#125;&#125; This is the output of the program. Found 12 at 1, 0 The break statement terminates the labeled statement; it does not transfer the flow of control to the label. Control flow is transferred to the statement immediately following the labeled (terminated) statement. The continue StatementThe continue statement skips the current iteration of a for, while , or do-while loop. The unlabeled form skips to the end of the innermost loop’s body and evaluates the boolean expression that controls the loop. The following program, ContinueDemo , steps through a String, counting the occurences of the letter “p”. If the current character is not a p, the continue statement skips the rest of the loop and proceeds to the next character. If it is a “p”, the program increments the letter count. 12345678910111213141516171819class ContinueDemo &#123; public static void main(String[] args) &#123; String searchMe = "peter piper picked a " + "peck of pickled peppers"; int max = searchMe.length(); int numPs = 0; for (int i = 0; i &lt; max; i++) &#123; // interested only in p's if (searchMe.charAt(i) != 'p') continue; // process p's numPs++; &#125; System.out.println("Found " + numPs + " p's in the string."); &#125;&#125; Here is the output of this program: Found 9 p’s in the string. To see this effect more clearly, try removing the continue statement and recompiling. When you run the program again, the count will be wrong, saying that it found 35 p’s instead of 9.A labeled continue statement skips the current iteration of an outer loop marked with the given label. The following example program, ContinueWithLabelDemo, uses nested loops to search for a substring within another string. Two nested loops are required: one to iterate over the substring and one to iterate over the string being searched. The following program, ContinueWithLabelDemo, uses the labeled form of continue to skip an iteration in the outer loop. 1234567891011121314151617181920212223242526class ContinueWithLabelDemo &#123; public static void main(String[] args) &#123; String searchMe = "Look for a substring in me"; String substring = "sub"; boolean foundIt = false; int max = searchMe.length() - substring.length(); test: for (int i = 0; i &lt;= max; i++) &#123; int n = substring.length(); int j = i; int k = 0; while (n-- != 0) &#123; if (searchMe.charAt(j++) != substring.charAt(k++)) &#123; continue test; &#125; &#125; foundIt = true; break test; &#125; System.out.println(foundIt ? "Found it" : "Didn't find it"); &#125;&#125; Here is the output from this program. Found it The return StatementThe last of the branching statements is the return statement. The return statement exits from the current method, and control flow returns to where the method was invoked. The return statement has two forms: one that returns a value, and one that doesn’t. To return a value, simply put the value (or an expression that calculates the value) after the return keyword. return ++count; The data type of the returned value must match the type of the method’s declared return value. When a method is declared void, use the form of return that doesn’t return a value. return; The Classes and Objects lesson will cover everything you need to know about writing methods.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的强、软、弱、虚引用]]></title>
    <url>%2Fposts%2F8a9fd61b%2F</url>
    <content type="text"><![CDATA[在 JDK 1.2 以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从 JDK 1.2 版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用（StrongReference） Object obj = new Object(); 如果一个对象具有强引用，则 GC(Garbage Collection) 时绝不会回收它。 当内存空间不足，JVM 宁愿抛出 OutOfMemoryError 错误，使程序异常终止。 软引用（SoftReference） java.lang.ref.SoftReference 用于描述还有用，但并非必须的对象。 当堆将发生 OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出 OOM。 软引用可用来实现内存敏感的高速缓存。(见后例） 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被 GC，JVM 就会把这个软引用加入到与之关联的引用队列中。 示例：实现学生信息查询操作时有两套数据操作的方案（如后退操作，查询上一个刚刚查询过的信息） 将得到的信息存放在内存中，后续查询则直接读取内存信息。 优点：读取速度快； 缺点：内存空间一直被占，若资源访问量不高，则浪费内存空间 每次查询均从数据库读取，然后填充到 TO 返回。 优点：内存空间将被 GC 回收，不会一直被占用。 缺点：在 GC 发生之前已有的 TO 依然存在，但还是执行了一次数据库查询，浪费IO 通过软引用解决 1234567891011121314151617ReferenceQueue queue = new ReferenceQueue();// 获取数据并缓存Object object = new Object();SoftReference softRef = new SoftReference(object, queue);// 下次使用时Object object = (Object)softRef.get();if (object == null)&#123; // 当软引用被回收后才重新获取 object = new Object();&#125;// 清理被收回后剩下来的软引用对象SoftReference ref = null;while((ref = queue.poll()) != null)&#123; // 清理工作&#125; 弱引用（WeakReference） java.lang.ref.WeakReference GC 时必定收回弱引用指向的内存空间 不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被 GC，JVM就会把这个弱引用加入到与之关联的引用队列中。 虚引用（PhantomReference） java.lang.ref.PhantomReference 虚引用不会决定对象的生命周期，也无法通过需引用来获取对象实例。仅用于在发生 GC 时接受一个系统通知。 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当 GC 准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ReferenceQueue queue = new ReferenceQueue();PhantomReference pr = new PhantomReference(object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 引用队列(Reference Queue) java.lang.ref.ReferenceQueue 引用队列配合 Reference 的子类等使用，当引用对象所指向的内存空间被 GC 回收后，该引用对象则被追加到引用队列的末尾（源码中 boolean enqueue(Reference&lt;? extends T&gt; r) { /* Called only by Reference class */说明只供Reference实例调用，且仅能调用一次）。引用队列有如下实例方法： Reference&lt;? extends T&gt; ReferenceQueue#poll()从队列中出队一个元素，若队列为空则返回null。 Reference&lt;? extends T&gt; ReferenceQueue#remove()从队列中出队一个元素，若没有则阻塞直到有元素可出队。 Reference&lt;? extends T&gt; ReferenceQueue#remove(long timeout)从队列中出队一个元素，若没有则阻塞直到有元素可出队或超过 timeout 指定的毫秒数（由于采用wait(long timeout)方式实现等待，因此时间不能保证）。 判断可达性/可触及性(Reachable) 单条引用链的可达性以最弱的一个引用类型来决定； 多条引用链的可达性以最强的一个引用类型来决定； 可达性分析用于判断对象是否存活。 以 GCRoots 的对象做为起点，从起点开始向下搜索，搜索的走过路径叫引用链，引用链上的对象判断为生存，当一个对象到 GCRoots 没有引用链时，判断对象死亡。 在 JVM 中，做为 GCRoots 的对象： 虚拟机栈(栈桢中的本地变量表)中的引用的对象 方法区中的类/静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中 JNI 的引用的对象 使用软引用构建敏感数据的缓存为什么需要使用软引用设想一个雇员信息系统。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览 Web 页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式 是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的 Java 对象的生命周期贯穿整个应用程序始终。 是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的 Java 对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。 很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。 我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的 Java 对象的引用，必将减少不必要的访问，大大提高程序的运行速度。 如何使用软引用SoftReference 的特点是它的一个实例保存对一个 Java 对象的软引用，该软引用的存在不妨碍 GC。也就是说，一旦 SoftReference 保存了对一个 Java 对象的软引用后，在垃圾线程对这个 Java 对象回收前，SoftReference 类所提供的 get() 方法返回 Java 对象的强引用。另外，一旦垃圾线程回收该 Java 对象之后，get() 方法将返回 null。 MyObject aRef = new MyObject();SoftReference aSoftRef = new SoftReference(aRef); 此时，对于这个 MyObject 对象，有两个引用路径，一个是来自 SoftReference 对象的软引用，一个来自变量 aRef 的强引用，所以这个MyObject 对象是强可及对象。 随即，我们可以结束 aReference 对这个MyObjec t实例的强引用: aRef = null 此后，这个 MyObject 对象成为了软可及对象。如果 GC，并不会因为有一个 SoftReference 的软引用而保留对象。JVM 的垃圾收集线程对软可及对象和其他一般 Java 对象进行了区别对待：软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出 OutOfMemoryError 之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过: MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 使用 ReferenceQueue 清除失去了软引用对象的 SoftReference作为一个 Java 对象，SoftReference 对象除了具有保存软引用的特殊性之外，也具有 Java 对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference 对象的 get() 方法返回 null，但这个 SoftReference 对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量 SoftReference 对象带来的内存泄漏。在 java.lang.ref 包里还提供了 ReferenceQueue。如果在创建 SoftReference 对象的时候，使用了一个 ReferenceQueue 对象作为参数提供给 SoftReference 的构造方法，如: 12ReferenceQueue queue = new ReferenceQueue();SoftReference ref = new SoftReference(aMyObject, queue); 那么当这个 SoftReference 所软引用的 aMyOhject 被 GC 的同时，ref 所强引用的 SoftReference 对象被列入 ReferenceQueue。也就是说，ReferenceQueue 中保存的对象是 Reference 对象，而且是已经失去了它所软引用的对象的 Reference 对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:1234567SoftReference ref = null;while ((ref = (EmployeeRef)q.poll()) != null) &#123;//清除ref&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[短路运算]]></title>
    <url>%2Fposts%2F9a2d411a%2F</url>
    <content type="text"><![CDATA[1if (refer != null &amp;&amp; refVar.isValidType()) &#123; &#125; 有值调用或赋值，没值不崩溃。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象]]></title>
    <url>%2Fposts%2F9e6fead7%2F</url>
    <content type="text"><![CDATA[抽象类 Abstract class通常，我们需要的是子类的对象，而非父类的对象。为了确保一个父类不被创建实例，可将其变为抽象类 抽象类仍可以放入引用变量 抽象类不能用new创建实例 抽象类必须有子类 抽象类可以有抽象方法，也可以有具体方法 抽象方法 Abstract method 抽象方法没有函数体，没有{}，其意义在于为抽象类的子类们定义某种协议（大家都必须实现这些方法）。 抽象方法必须以被重写的方式来实现。 继承树中第一个具体类必须实现其顶部所有抽象类的所有抽象方法。 抽象方法必须放入抽象类内，抽象类内可以有非抽象方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量]]></title>
    <url>%2Fposts%2F13ffbe88%2F</url>
    <content type="text"><![CDATA[Java 变量 变量的类型 成员变量(Field) :类体内的变量 静态变量：用static修饰，是属于类的。 实例变量/非静态变量：无static修饰，是属于实例的。 局部变量 形参 方法内的局部变量 代码块内的局部变量 静态变量的初始化总是先于实例变量的初始化，无关声明顺序，因此： 两个类变量不能非法向前引用。 两个实例变量不能非法向前引用。 但实例变量总是可以引用类变量。 变量的默认值实例变量永远都会有默认值。即声明未赋值时依然可以调用。 基本类型中的整数类型（byte、short、int和long），则值是0。 基本类型中的浮点类型（float、double），则值是0.0。 基本类型中的字符类型（char），则值是’\u0000’。 基本类型中的布尔类型（boolean），则值是false。 引用类型（类、接口和数组），则为 null 局部变量没有默认值不指定初始值是菜鸟行为。 变量的初始化实例变量的初始化 定义实例变量时指定初始值 非静态初始化块中对实例变量指定初始值（对未声明变量直接赋值） 构造器中对实例变量指定初始值前两项先于第三项。前两项的顺序按照代码中的顺序 静态变量的初始化 定义类变量时指定初始值 静态初始化块中对类变量指定初始值 静态变量没有默认值，必须显示指定初始值 Final 静态变量的初始化1.定义时123public class Foo &#123; public static final int FOO_X = 25;&#125; 2.在静态初始化块内1234567public class Bar &#123; public static final double BAR_SIGN; static &#123; BAR_SING = (double)Math.random() &#125;&#125; 变量的声明类型与对象的实际类型不同时（实际类型是声明类型的子类）当发生上述情况，即变量的编译时类型与运行时类型不同时： 通过变量访问它引用的对象的实例变量时：该实例变量的值由声明该变量的类型决定。 通过变量调用它引用的类型的方法时，该方法行为将由它实际引用的对象来决定。 静态变量只有在第一次加载类的时候才会被初始化，而不是每次创建实例都初始化。因此对于该类的所有实例，值都相同。静态变量是所有实例共享的，相同的值。某个对象修改了静态变量的值后，其他对象访问改静态变量得到的是修改后的值。 实例变量：每个实例独占一个，1000个对象有1000个实例变量，属于对象。 静态变量：每个类只有一个，1000个对象共享同1个，属于类。即使没有对象，也存在着。 创建对象前，静态变量必须被初始化完毕。 调用类中的静态方法前，静态变量必须被初始化完毕。 通过类名（而非对象名）访问静态变量。 123456789101112131415class Player &#123; static int playerCounst; // int 类型默认值为0 private String name; public Player(String n) &#123; name = n; playerCount++; &#125; public class PlayerTestDrive &#123; public static void main(String[] args) &#123; System.out.pintln(Player.playerCount); Player one = new Player("Tiger Woods"); Systen.out.println(Player.playerCount); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包装类型]]></title>
    <url>%2Fposts%2F7f22fd31%2F</url>
    <content type="text"><![CDATA[Java 虽然是面向对象编程语言，但是为了编程的方便引入了基本数据类型。为了能将这些基本数据类型当成对象操作，Java 为每个基本数据类型引入了对应的包装类型。 Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换 boolean—Boolean char—Character byte—Byte short—Short int—Integer long—Long floate—Float double—Double 123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将 int 类型的3自动装箱成 Integer 类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成 int 类型再和 c 比较 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偷资源]]></title>
    <url>%2Fposts%2Fefaa62e3%2F</url>
    <content type="text"><![CDATA[油 2-2E(1~3SS) 2-3AEI(1~4SS) 4-1F(DD练级) 弹 2-3AEI(1~4SS) 钢 3-2B(1~4SS旗舰168，回避13x2) 402EG(4~5SS) 铝 4-3E(DD练级)]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造配方]]></title>
    <url>%2Fposts%2Fa32fa04c%2F</url>
    <content type="text"><![CDATA[秋云250 30 250 31 Z3250 30 250 31 Z1 长门400 30 600 30 赤城 马路油1500 1500 2000 1000 1 大和明石 阿贺野 能代 三隈1500 1500 2000 1000 1 大和 武藏4000 7000 7000 2000 20 榛名/大和 Zara3500 4500 4500 2000 20 Libeccio Bismarck4000 6000 7000 2000 20 Z1 Saratoga4000 2000 5000 7000 20 Iowa 瑞穗 秋津丸 大凤 神威4000 2000 5000 6000 20 Iowa明石 伊4013500 4500 4500 2000 1 榛名]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支援舰队]]></title>
    <url>%2Fposts%2Fe305fe87%2F</url>
    <content type="text"><![CDATA[炮击支援 3BB（3炮1电 / 2炮2电） 2DD（全炮） 1CV（全舰爆） 雷击支援 航空支援]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[练级]]></title>
    <url>%2Fposts%2Fd84d1c15%2F</url>
    <content type="text"><![CDATA[CL DD 1改CLT 4-3 旗舰(反潜套) BB(二连) 2CLT(甲标水听主炮) 2CVL(开幕强化 反潜强化 彩云 制空&gt;48) CA BB CV 3-2A 旗舰位 CA(2连) 航巡(2连 熟练舰载机整备员) BB(2连 水爆) CV(大攻小爆 熟练舰载机整备员) 23号位 打手 x 2 红脸替换 火力 &lt; 100，命中，无2连，无CI，推荐CA/CL/夕立/凌波 旗舰非BB 要求同上，推荐BBV 4号位：蹭经验 随意 5号位：开幕制空 CVL 红脸不换 中破可用 舰爆彩云 无其他制空带零战62 6号位：MT 低级168 中破可用-1甲标 或 4连酸素]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任务]]></title>
    <url>%2Fposts%2F5ee7f95d%2F</url>
    <content type="text"><![CDATA[补给舰 2-2(4~6SS) 2-3(2~4SS) 4-3 5-4 空母 2-2(4~6SS) 2-3(2~4SS) 4-2 5-4 2图Boss 2-2(2CVL+4SS) 2-3(2~4SS) 3图Boss 3-4(4~5SS)或不做 4图Boss 4-2(4~5SS)或不做]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远征]]></title>
    <url>%2Fposts%2F6104db5e%2F</url>
    <content type="text"><![CDATA[综合 21北方鼠输送作战 1CL + 4DD 37东京急行 1CL + 5DD 38东京急行（二）5DD 油 5海上护卫任务 1CL + 2DD 21北方鼠输送作战 1CL + 4DD 38东京急行（二）5DD 弹 2长距离练习航海 5海上护卫任务 1CL + 2DD 37东京急行 1CL + 5DD 钢 3警备任务 37东京急行 1CL5DD 38东京急行（二）5DD 铝 5海上护卫任务 1CL + 2DD 6防空射击演习 11铝输送任务 2DD]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阵型]]></title>
    <url>%2Fposts%2F71d2d6e7%2F</url>
    <content type="text"><![CDATA[单纵阵 强化炮雷伤害、雷击命中率 削弱对潜 复纵阵 强化炮击命中率 强化对空 各项均衡 对敌方含有一只 SS 对水雷舰队 轮型阵 大幅强化对空 大幅强化对潜 提高援护旗舰发生率 削弱火力 大幅削弱雷击命中率 梯形阵 玄学 略微提高炮击回避率 单横阵 大幅强化对潜 小幅幅提高炮击回避率 小幅提高雷击回避]]></content>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带路]]></title>
    <url>%2Fposts%2Ff5e02980%2F</url>
    <content type="text"><![CDATA[镇守府海域1-5 舰队编制 CVL（大鹰/空船） DE DD/CL DD/CL 五十铃改二无条件开幕反潜 DE反潜60可开幕反潜 其他反潜堆至100，考虑CLT/CT 1-6 舰队编制 CL DD DD DD DD DD 五十铃改二对空CI+开幕反潜 由良改二水爆水战 秋月级 (A)-【E(反潜)】-(G)-【F(轮形)】-【B(轮形,大破进击)】-(N) 旗舰带损管，无消耗 西南诸岛海域北方海域3-1 舰队编制 大船 大船 大船 大船 CV CV 制空 （优）108/（确）216 西方海域南方海域中部海域]]></content>
      <categories>
        <category>舰队 Collection</category>
      </categories>
      <tags>
        <tag>舰队 Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1234 4.yes ↩]]></content>
  </entry>
</search>
